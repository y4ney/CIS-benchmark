{
  "type": "docker",
  "cis_id": "v1.1.0-07-06-2017",
  "cis_title": "CIS Docker Community Edition Benchmark",
  "usage_version": "17.06<=Docker Version<18.09",
  "description": "CIS Docker Community Edition Benchmark",
  "overview": "本文档面向计划开发、部署、评估或保护包含Docker CE 17.06或更高版本技术的解决方案的系统和应用程序管理员、安全专家、审计师、服务台和平台部署人员。",
  "intended_audience": "本文档CIS Docker CE 17.06基准为建立Docker CE容器版本17.06的安全配置态提供了规范性指导。本指南针对RHEL 7和Debian 8上的Docker CE 17.06进行了测试。要获取本指南的最新版本，请访问http://benchmarks.cisecurity.org。如果您有任何问题、意见或确定了改进本指南的方法，请写信至feedback@cisecurity.org。",
  "groups": [
    {
      "id": "1",
      "title": "主机配置",
      "description": "本节介绍了您应该遵循的安全建议，以准备您计划用于执行容器化工作负载的主机。保护Docker主机并遵循您的基础设施安全最佳实践将为执行容器化工作负载奠定坚实和安全的基础。",
      "groups": [
        {
          "id": "1.1",
          "title": "确保已为容器创建单独的分区",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "所有Docker容器及其数据和元数据都存储在/var/lib/docker目录下。默认情况下/var/lib/docker应安装在/或/var分区下，具体取决于所使用的Linux操作系统的配置方式。",
          "rationale": "Docker依赖于/var/lib/docker作为存储所有Docker相关文件（包括镜像）的默认目录。此目录可能会快速填充，导致Docker和主机无法使用。因此，您应该创建一个单独的分区（逻辑卷）来存储Docker文件。",
          "audit": "在Docker主机上执行grep /var/lib/docker /etc/fstab命令，这应该会返回/var/lib/docker挂载点的分区详细信息。\r\n或者执行mountpoint -- \"$(docker info -f '{{ .DockerRootDir }}')\"命令，这应该会返回配置的根目录是否是挂载点。",
          "remediation": "对于新安装，您应该为/var/lib/docker挂载点创建一个单独的分区。对于已经安装的系统，您应该使用Linux中的逻辑卷管理器（LVM）创建一个新分区。",
          "impact": "无",
          "default_value": "默认情况下，/var/lib/docker挂载在/或/var分区下，具体取决于操作系统的配置方式。",
          "references": "https://www.projectatomic.io/docs/docker-storage-recommendation/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "1.2",
          "title": "确保容器主机已加固",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "容器主机能够运行一个或多个容器。最重要的是对主机进行加固，以减少主机安全配置错误。",
          "rationale": "您应该遵循基础设施安全最佳实践，并加固主机操作系统。保持加固主机系统将确保主机漏洞得到缓解。不加固主机系统可能会导致安全漏洞和漏洞。",
          "audit": "确保遵循特定于主机的安全准则。询问系统管理员当前主机系统当前应遵守哪个安全基准，并检查与该标准相关的安全标准目前是否到位。",
          "remediation": "您可以考虑容器主机的各种CIS安全基准。如果您有其他安全指南或监管要求需要遵守，请在您的环境中遵循它们。",
          "impact": "无",
          "default_value": "默认情况下，主机具有出厂设置，并且不会加固。",
          "references": "https://docs.docker.com/engine/security/security/\r\nhttps://learn.cisecurity.org/benchmarks\r\nhttps://docs.docker.com/engine/security/security/#other-kernel-security-features\r\nhttps://grsecurity.net/\r\nhttps://en.wikibooks.org/wiki/Grsecurity\r\nhttps://pax.grsecurity.net/\r\nhttp://en.wikipedia.org/wiki/PaX",
          "auto": false
        },
        {
          "id": "1.3",
          "title": "确保Docker的版本是最新的",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "Docker经常提出一些发行版本以解决安全漏洞，解决产品错误并引入新功能。您应该根据组织的一般IT安全政策，密切关注这些产品更新，并尽可能频繁地升级。",
          "rationale": "您应该执行docker version命令，以验证Docker版本是否符合您正在运行的应用程序的要求。应该注意的是，最新的版本不是安全要求，前提是您使用的版本不包含任何关键或高安全性漏洞。",
          "audit": "确保遵循特定于主机的安全准则。询问系统管理员当前主机系统当前应遵守哪个安全基准，并检查与该标准相关的安全标准目前是否到位。",
          "remediation": "您应该监控Docker版本的版本，并确保您的软件已按要求更新。",
          "impact": "您应该对Docker版本更新进行风险评估，并审查它们可能会如何影响您的运营。您应该知道，使用Docker的第三方产品可能需要支持较旧的主要版本Docker，这应该根据您组织的一般IT安全政策进行审查，特别是在旧版本的安全漏洞已公开披露的情况下。",
          "default_value": "不适用",
          "references": "https://docs.docker.com/engine/installation/\r\n https://github.com/moby/moby/releases/latest\r\nhttps://github.com/docker/docker-ce/releases/latest",
          "auto": false
        },
        {
          "id": "1.4",
          "title": "确保只允许受信任的用户控制Docker守护进程",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "Docker守护进程需要访问Docker socket，默认情况下，属于root用户和docker用户组。",
          "rationale": "Docker允许您在Docker主机和游客容器之间共享目录，而不会限制容器的访问权限。这意味着您可以启动一个容器，并将主机上的/目录映射到容器。然后，容器将能够不受任何限制地修改您的主机文件系统。这意味着您只需成为docker组的成员，然后启动一个映射主机root的/目录的容器即可获得更高的权限。",
          "audit": "在docker主机上执行getent group docker命令，并确保只有受信任的用户是docker组的成员。",
          "remediation": "您应该从docker组中删除任何不受信任的用户。此外，您不应该创建从主机到容器卷的敏感目录的映射。",
          "impact": "如果实施了操作说明，作为正常用户构建和执行容器的权利将受到限制。",
          "default_value": "不适用",
          "references": "https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface\r\nhttps://www.andreas-jung.com/contents/on-docker-security-docker-group-considered-harmful\r\nhttp://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/",
          "auto": false
        },
        {
          "id": "1.5",
          "title": "确保为Docker守护进程配置审计",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "审计所有Docker守护进程活动。",
          "rationale": "除了审计正常的Linux文件系统和系统调用外，您还应该审计Docker守护进程。因为这个守护进程以root权限运行。审计其活动和使用情况非常重要。",
          "audit": "执行auditctl -l | grep /usr/bin/docker命令，验证Docker守护进程是否有审计规则。这应该会显示与Docker守护进程相关的规则。",
          "remediation": "您应该为Docker守护进程添加规则。例如，在/etc/audit/audit.rules 中加入-w /usr/bin/docker -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "默认情况下，Docker守护进程不会被审计。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "1.6",
          "title": "确保为Docker文件和目录配置审计 - /var/lib/docker",
          "profile_application": "Level 2 - Linux Host OS",
          "description": "审计/var/lib/docker。",
          "rationale": "除了审计正常的Linux文件系统和系统调用外，您还应该审计所有与Docker相关的文件和目录。Docker守护进程以root权限运行，其行为取决于一些密钥文件和目录。/var/lib/docker就是这样一个目录。由于它包含有关容器的所有信息，因此应该对其进行审计。",
          "audit": "您应该验证是否有一个适用于/var/lib/docker目录的审计规则。例如，您可以执行auditctl -l | grep /var/lib/docker命令。这应该列出/var/lib/docker目录的规则。",
          "remediation": "您应该为/var/lib/docker目录添加规则。例如，在/etc/audit/audit.rules 中加入-w /var/lib/docker -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "auto": true,
          "level": "high"
        },
        {
          "id": "1.7",
          "title": "确保为Docker文件和目录配置审计 - /etc/docker",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "审计/etc/docker。",
          "rationale": "除了审计正常的Linux文件系统和系统调用外，您还应该审计所有与Docker相关的文件和目录。Docker守护进程以root权限运行，其行为取决于一些密钥文件和目录，其中之一是/etc/docker。这包含用于Docker守护进程和Docker客户端之间TLS通信的各种证书和密钥，因此应该进行审计。",
          "audit": "您应该验证是否有一个适用于/etc/docker目录的审计规则。例如，您可以执行auditctl -l | grep /etc/docker命令。这应该列出/etc/docker目录的规则。",
          "remediation": "您应该为/etc/docker目录添加规则。例如，在/etc/audit/audit.rules 中加入-w /etc/docker -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "auto": true,
          "level": "high"
        },
        {
          "id": "1.8",
          "title": "确保为Docker文件和目录配置审计 - docker.service",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "如果存在docker.service文件，请审计docker.service。",
          "rationale": "除了审计正常的Linux文件系统和系统调用外，您还应该审计所有与Docker相关的文件和目录。Docker守护进程以root权限运行，其行为取决于一些密钥文件和目录，其中之一是/etc/docker。如果管理员更改了守护进程参数，则可能存在docker.service文件。如果是这样，它包含Docker守护进程的各种参数，应该进行审计。",
          "audit": "步骤1：执行systemctl show -p FragmentPath docker.service命令，找出文件位置。\r\n步骤2：如果文件不存在，则此建议不适用。如果文件确实存在，请执行auditctl -l | grep docker.service命令验证是否有与文件相对应的审计规则，这应该会显示docker.service的规则。",
          "remediation": "如果文件存在，您应该为/etc/docker目录添加规则。例如，在/etc/audit/audit.rules 中加入-w /usr/lib/systemd/system/docker.service -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。系统上可能没有文件docker.service。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "auto": true,
          "level": "high"
        },
        {
          "id": "1.9",
          "title": "确保为Docker文件和目录配置审计 - docker.socket",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "如果存在docker.socket文件，请审计docker.socket。",
          "rationale": "除了审计您的常规Linux文件系统和系统调用外，还要审核所有与Docker相关的文件和目录。Docker守护进程以根权限运行。它的行为取决于一些关键文件和目录。docker.socket就是这样一个文件。它包含Docker守护进程套接字的各种参数。如果适用，必须进行审计。",
          "audit": "步骤1：执行systemctl show -p FragmentPath docker.socket命令，找出文件位置。\r\n步骤2：如果文件不存在，则此建议不适用。如果文件确实存在，请执行auditctl -l | grep docker.socket命令验证是否有与文件相对应的审计规则，这应该会显示docker.socket的规则。",
          "remediation": "如果文件存在，您应该为/etc/docker目录添加规则。例如，在/etc/audit/audit.rules 中加入-w /usr/lib/systemd/system/docker.socket -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。系统上可能没有文件docker.socket。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "auto": true,
          "level": "high"
        },
        {
          "id": "1.10",
          "title": "确保为Docker文件和目录配置审计 - /etc/default/docker",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "如果存在/etc/default/docker，请审计/etc/default/docker。",
          "rationale": "除了审计正常的Linux文件系统和系统调用外，您还应该审计所有与Docker相关的文件和目录。Docker守护进程以root权限运行，其行为取决于一些密钥文件和目录，其中之一是docker.socket。如果管理员更改了守护进程参数，则可能存在docker.service文件。如果是这样，它包含Docker守护进程的各种参数，应该进行审计。",
          "audit": "您应该执行auditctl -l | grep /etc/default/docker命令验证是否有与/etc/default/docker文件关联的审计规则。这应该会显示/etc/default/docker文件的规则。",
          "remediation": "您应该为/etc/docker目录添加规则。例如，在/etc/audit/audit.rules 中加入-w /etc/default/docker -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。系统上可能没有/etc/default/docker 。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "1.11",
          "title": "确保为Docker文件和目录配置审计 - /etc/docker/daemon.json",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "如果存在/etc/docker/daemon.json，请审计/etc/docker/daemon.json。",
          "rationale": "除了审计正常的Linux文件系统和系统调用外，您还应该审计所有与Docker相关的文件和目录。Docker守护进程以root权限运行，其行为取决于一些密钥文件和目录，其中之一是/etc/docker/daemon.json。如果是这样，它包含Docker守护进程的各种参数，应该进行审计。",
          "audit": "您应该执行auditctl -l | grep /etc/docker/daemon.json命令验证是否有与/etc/docker/daemon.json文件关联的审计规则。这应该会显示/etc/docker/daemon.json文件的规则。",
          "remediation": "如果文件存在，您应该为/etc/docker/daemon.json文件添加规则。例如，在/etc/audit/audit.rules 中加入-w /etc/docker/daemon.json -k docker规则，然后执行service auditd restart命令重启审计工具。",
          "impact": "审计可以生成大型日志文件。您应该确保这些定期轮换和存档。还应该为审计日志创建一个单独的分区，以避免填充任何其他关键分区。",
          "default_value": "Docker相关文件和目录不会被审计。系统上可能没有/etc/docker/daemon.json。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html\r\nhttps://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "1.12",
          "title": "确保为Docker文件和目录配置审计 - /usr/bin/docker-containerd",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "如果存在/usr/bin/docker-containerd，请审计/usr/bin/docker-containerd。",
          "rationale": "除了审计您的常规Linux文件系统和系统调用外，还要审核所有与Docker相关的文件和目录。Docker守护进程以根权限运行。它的行为取决于一些关键文件和目录。/usr/bin/docker-containerd就是这样一个文件。Docker现在依靠containerdand runC来生成容器。如果适用，必须进行审计。",
          "audit": "验证是否有对应于/usr/bin/docker-containerd文件的审计规则。例如，执行以下命令：auditctl -l | grep /usr/bin/docker-containerd\r\n这应该列出/usr/bin/docker-containerd文件的规则。",
          "remediation": "为/usr/bin/docker-containerd文件添加规则。例如，在/etc/audit/audit.rules文件中添加以下行：-w /usr/bin/docker-containerd -k docker\r\n然后，重新启动审计守护进程。例如:service auditd restart",
          "impact": "审计会生成相当大的日志文件。确保定期轮换和归档。此外，创建一个单独的审计分区，以避免填充根文件系统。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。文件/usr/bin/docker- containerd可能无法在系统上使用。在这种情况下，这项建议不适用。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html\r\nhttps://github.com/docker/docker/pull/20662\r\nhttps://containerd.tools/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "1.13",
          "title": "确保为Docker文件和目录配置审计 - /usr/bin/docker-runc",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "审计/usr/bin/docker-runc（如果适用）。",
          "rationale": "除了审计您的常规Linux文件系统和系统调用外，还要审核所有与Docker相关的文件和目录。Docker守护进程以root权限运行。它的行为取决于一些关键文件和目录。/usr/bin/docker-runc就是这样一个文件。Docker现在依靠容器和runC来生成容器。如果适用，必须进行审计。",
          "audit": "验证是否有与/usr/bin/docker-runc文件相对应的审计规则。例如，执行以下命令：auditctl -l | grep /usr/bin/docker-runc\r\n这应该列出/usr/bin/docker-runc文件的规则。",
          "remediation": "为/usr/bin/docker-runc文件添加规则。例如，在/etc/audit/audit.rules文件中添加以下行：-w /usr/bin/docker-runc -k docker\r\n然后，重新启动审计守护进程。例如，service auditd restart",
          "impact": "审计会生成相当大的日志文件。确保定期轮换和归档。此外，创建一个单独的审计分区，以避免填充根文件系统。",
          "default_value": "默认情况下，Docker相关文件和目录不会被审计。文件/usr/bin/docker- runc可能无法在系统上使用。在这种情况下，这项建议不适用。",
          "references": "https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Security_Guide/chap-system_auditing.html\r\nhttps://github.com/docker/docker/pull/20662\r\nhttps://containerd.tools/\r\nhttps://github.com/opencontainers/runc",
          "auto": true,
          "level": "medium"
        }
      ]
    },
    {
      "id": "2",
      "title": "Docker守护进程配置",
      "description": "本节列出了更改和保护Docker守护进程行为的建议。本节下的设置会影响所有容器实例。\r\n注意：Docker守护进程选项也可以使用/etc/sysconfig/docker、/etc/default/docker、systemd单元文件或/etc/docker/daemon.json等文件进行控制。此外，请注意，守护进程模式下的Docker可以识别为/usr/bin/dockerd，也可以将-d或daemon标识为docker服务的参数。",
      "checks": [
        {
          "id": "2.1",
          "title": "确保默认桥接器上的容器之间的网络流量受到限制",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认情况下，默认网络桥接器上同一主机上的容器之间允许所有网络流量。如果没有，请限制所有容器间通信。将需要通信的特定容器链接在一起。或者，您可以创建自定义网络，并且只能加入需要与该自定义网络通信的容器。",
          "rationale": "默认情况下，默认网络桥接器上同一主机上的所有容器之间都启用了不受限制的网络流量。因此，每个容器都有可能在同一台主机上读取跨容器网络的所有数据包。这可能会导致意外和不必要的信息泄露给其他容器。因此，限制默认网络桥上的容器间通信。",
          "audit": "运行docker network ls --quiet | xargs docker network inspect --format '{{ .Name }}: {{ .Options }}'命令，并验证默认网络桥接器是否已配置为限制容器间通信。\r\n对于默认网络桥接器，它应该返回com.docker.network.bridge.enable_icc:false。",
          "remediation": "编辑Docker守护进程配置文件，以确保icc被禁用。它应该包括以下设置:\"icc\": false\r\n或者直接运行docker守护进程，并将--icc=false作为参数传递。例如，dockerd --icc=false。\r\n或者，您可以按照Docker文档创建自定义网络，并且仅加入需要与该自定义网络通信的容器。--icc参数仅适用于默认的docker桥接器，如果使用自定义网络，则应采用分割网络的方法。",
          "impact": "容器间通信将在默认网络桥接器上禁用。如果需要同一主机上的容器之间进行任何通信，则需要使用容器链接或自定义网络进行显式定义。",
          "default_value": "默认情况下，默认网络桥接器上允许所有容器间通信。",
          "references": "https://docs.docker.com/engine/userguide/networking/\r\nhttps://docs.docker.com/engine/userguide/networking/default_network/container-communication/#communication-between-containers",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.2",
          "title": "确保日志记录级别设置为info",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "将Docker守护进程日志级别设置为info。",
          "rationale": "设置适当的日志级别，将Docker守护进程配置为记录您稍后要查看的事件。基本info日志级别及以上将捕获除调试日志以外的所有日志。除非有需要，否则您不应在debug日志级别运行Docker守护进程。",
          "audit": "要确认此设置，应完成审查dockerd启动选项和审查/etc/docker/daemon.json中任何设置的组合。要查看dockerd启动选项，请执行ps -ef | grep dockerd命令\r\n确保---log-level参数是否存在，或者如果存在，则将其设置为info。\r\n对于此设置，还应查看/etc/docker/daemon.json的内容。",
          "remediation": "确保Docker守护进程配置文件包含以下配置\"log-level\": \"info\"\r\n或者，按如下方式运行Docker守护进程：dockerd --log-level=\"info\"",
          "impact": "无",
          "default_value": "默认情况下，Docker守护进程的日记级别为info",
          "references": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.3",
          "title": "确保允许Docker对iptables进行更改",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "iptables防火墙用于设置、维护和检查Linux内核中的IP数据包过滤器规则表。应允许Docker守护进程对iptables规则集进行更改。",
          "rationale": "除非您允许，否则Docker永远不会更改您的系统iptables规则。如果您确实允许这样做，Docker服务器将自动进行任何必要的更改。我们建议让Docker自动更改iptables，以避免网络配置错误，这可能会影响容器之间以及与外部世界的通信。此外，每当你增加容器或者修改网络选项时，这减少了更新iptables的管理开销。",
          "audit": "要确认此设置，您应该查看dockerd启动选项和/etc/docker/daemon.json。要查看dockerd启动选项，请执行ps -ef | grep dockerd命令。确保--iptables参数不存在或未设置为false。对于此设置，还应查看/etc/docker/daemon.json的内容。",
          "remediation": "不要使用--iptables=false参数运行Docker守护进程。例如，不要像下面那样启动Docker守护进程：dockerd --iptables=false",
          "impact": "Docker守护进程服务要求在启动前启用iptables规则。在Docker守护进程操作期间对iptables的任何重新启动都可能导致Docker创建的规则丢失。在iptables安装中添加iptables-persistent可以帮助减轻这种影响。",
          "default_value": "默认情况下，iptables设置为true。",
          "references": "https://docs.docker.com/engine/userguide/networking/default_network/container-communication/\r\nhttps://fralef.me/docker-and-iptables.html",
          "auto": true,
          "level": "high"
        },
        {
          "id": "2.4",
          "title": "确保不使用不安全的仓库",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "Docker认为私有仓库既是安全的又是不安全的。默认情况下，仓库被认为是安全的。应该注意的是，本机Docker授权验证插件只是执行此检测项的一种方法，因此在将其评估为通过或不通过之前，应审查可能正在使用的其他方法。",
          "rationale": "一个安全的仓库要使用TLS。仓库的CA证书的副本要放在Docker主机上，目录为/etc/docker/certs.d/<registry-name>/。不安全的仓库是指没有有效仓库证书的仓库，或者没有使用TLS的仓库。不应使用不安全的仓库，因为它们存在拦截和修改流量的风险。\r\n此外，一旦仓库被标记为不安全，如docker pull、docker push和docker search这类命令将不会导致错误消息，用户可能会无限期地处理此类不安全的仓库，而不会被告知潜在泄露的风险。",
          "audit": "您应该执行docker info --format 'Insecure Registries: {{.RegistryConfig.InsecureRegistryCIDRs}}'命令，以了解是否正在使用任何不安全的仓库。\r\n如果您使用的是docker本机授权认证，则应确保将--authorization-plugin参数设置适当。还应审查/etc/docker/daemon.json的内容。",
          "remediation": "步骤1：安装/创建授权认证插件。\r\n第2步：根据需要配置授权认证策略。第3步：启动docker守护进程：dockerd --authorization-plugin=<PLUGIN_ID>",
          "impact": "每个Docker命令都需要通过授权认证插件机制。这可能会对性能产生影响。或许可以使用不影响此性能的替代机制。",
          "default_value": "默认情况下，不会设置授权认证插件。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#access-authorization\r\nhttps://docs.docker.com/engine/extend/plugins_authorization/\r\nhttps://github.com/twistlock/authz",
          "auto": true,
          "level": "high"
        },
        {
          "id": "2.5",
          "title": "确保未使用 aufs 存储驱动程序",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "不要使用aufs作为Docker实例的存储驱动程序。",
          "rationale": "aufs存储驱动程序是Linux系统上使用的最古老的存储驱动程序。它基于Linux内核补丁合集，将来不太可能合并到主操作系统内核中。众所周知，aufs驱动程序还会导致一些严重的内核崩溃。aufs仅在使用Docker的系统中具有遗留支持。最重要的是，在许多使用最新Linux内核的Linux发行版中，aufs不是一个受支持的驱动程序。",
          "audit": "执行docker info --format 'Storage Driver: {{ .Driver }}'命令，并验证aufs没有用作存储驱动程序。该命令不应返回aufs。",
          "remediation": "不要明确使用 aufs 作为存储驱动程序。例如，请勿按如下所示启动Docker守护进程：dockerd --storage-driver aufs",
          "impact": "Aufs是唯一允许容器共享可执行和共享库内存的存储驱动程序。如果您正在使用同一程序或库运行数千个容器，这可能会有用，但应根据组织的安全策略审查其使用情况。",
          "default_value": "默认情况下，Docker在大多数平台上使用devicemapper作为存储驱动程序。默认存储驱动程序可能因您的操作系统供应商而异。您应该使用首选供应商推荐的存储驱动程序，该驱动程序符合正在部署的应用程序的政策。",
          "references": "https://docs.docker.com/engine/userguide/storagedriver/selectadriver/#supported-backing-filesystems\r\nhttp://muehe.org/posts/switching-docker-from-aufs-to-devicemapper/\r\nhttp://jpetazzo.github.io/assets/2015-03-05-deep-dive-into-docker-storage-drivers.html#1\r\nhttps://docs.docker.com/engine/userguide/storagedriver/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.6",
          "title": "确保配置了Docker守护进程的TLS身份验证",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "Docker守护进程可以通过TCP端口远程提供服务。如果需要，您应该确保配置了TLS身份验证，以限制通过IP地址和端口访问Docker守护进程。",
          "rationale": "默认情况下，Docker守护进程绑定到非网络Unix套接字，并使用root权限运行。如果您将默认的Docker守护进程绑定更改为TCP端口或任何其他Unix套接字，则任何有权访问该端口或套接字的人都可以完全访问Docker守护进程，从而反过来访问主机系统。因此，您不应该将Docker守护进程绑定到另一个IP/端口或Unix套接字。\r\n如果您必须通过网络套接字公开Docker守护进程，则应为守护进程和任何Docker Swarm API（如果它们正在使用）配置TLS身份验证。这种类型的配置将通过网络与Docker守护进程的连接限制在数量有限的能够访问TLS客户端凭据的客户端。",
          "audit": "要确认此设置，请查看dockerd启动选项和/etc/docker/daemon.json。要查看dockerd启动选项，请执行ps -ef | grep dockerd命令，确保存在以下参数：--tlsverify\n--tlscacert\n--tlscert\n--tlskey\n/etc/docker/daemon.json的内容也应确保这些设置到位。",
          "remediation": "按照Docker文档或其他参考文献中提到的步骤操作。",
          "impact": "您需要管理和保护Docker守护进程和Docker客户端的证书和密钥。",
          "default_value": "默认情况下，没有配置TLS身份验证。",
          "references": "https://docs.docker.com/engine/security/https/",
          "auto": true,
          "level": "high"
        },
        {
          "id": "2.7",
          "title": "确保默认限制配置正确",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "在您的环境中酌情设置默认的ulimit选项。",
          "rationale": "ulimit提供对shell及其启动的进程可用资源的控制。明智地设置系统资源限制可以让您免受fork炸弹等灾难的影响。有时，即使是友好的用户和合法的流程也可能过度使用系统资源，并可能使系统无法使用。\r\n为Docker守护进程设置默认ulimit将强制执行所有容器实例的ulimit。在这种情况下，您无需为每个容器实例设置ulimit。但是，如果需要，可以在容器运行时覆盖默认的ulimit。因此，为了正确控制系统资源，请根据环境中的需要定义默认限制。",
          "audit": "要确认此设置，您应该查看dockerd启动选项和/etc/docker/daemon.json中的任何设置。要查看dockerd启动选项，请执行ps -ef | grep dockerd命令\r\n确保适当地设置--default-ulimit参数。对于此设置，还应查看/etc/docker/daemon.json的内容。",
          "remediation": "在守护进程模式下运行Docker，并根据您的安全策略，酌情使用各自的ulimit传递--default-ulimit作为参数。例如，dockerd --default-ulimit nproc=1024:2048 --default-ulimit nofile=100:200",
          "impact": "如果ulimits设置不正确，这可能会导致系统资源问题，并可能导致拒绝服务。",
          "default_value": "默认情况下，没有设置ulimit。",
          "references": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/#default-ulimits",
          "auto": false
        },
        {
          "id": "2.8",
          "title": "启用用户命名空间支持",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您应该在Docker守护进程中启用用户命名空间支持，以利用容器用户来托管用户重新映射。如果您正在使用的容器没有在容器镜像中定义显式容器用户，则此建议是有益的。如果您使用的容器镜像具有预定义的非root用户，则可能会跳过此建议，因为此功能仍处于起步阶段，并可能导致不可预测的问题或配置困难。",
          "rationale": "Docker守护进程中的Linux内核“用户命名空间”支持为Docker主机系统提供了额外的安全性。它允许容器具有主机系统使用的传统用户和组范围之外的唯一用户和组ID范围。\r\n例如，root用户可以在容器中具有预期的管理权限，但可以有效地映射到主机系统上的无特权UID。",
          "audit": "ps -p $(docker inspect --format='{{ .State.Pid }}' <CONTAINER ID>) -o pid,user\r\n上述命令将找到容器的PID，然后列出关联的主机用户与容器过程。如果容器进程作为root进程运行，那么这配置可能不符合您组织的安全策略。\r\n或者，您可以运行 docker info --format '{{ .SecurityOptions }}' 命令，以确保userns列在Security Options下。",
          "remediation": "请参阅Docker文档，了解根据您的要求进行配置的各种方式。您的步骤也可能因平台而异。例如，在Red Hat,上，sub-UIDs和sub-GIDs映射创建不会自动工作。您可能需要创建自己的映射。\r\n高级步骤如下：\r\n步骤1：确保文件/etc/subuid和/etc/subgid存在：touch /etc/subuid /etc/subgid\r\n步骤2：使用--userns-remap标志启动docker守护进程：dockerd --userns-remap=default",
          "impact": "用户命名空间重新映射与许多Docker功能不兼容，目前还破坏了其一些功能。有关详细信息，请参阅Docker文档和包含的链接。",
          "default_value": "默认情况下，用户命名空间不会重新映射。应考虑根据所用应用程序的要求和组织的安全政策实施这一点。",
          "references": "http://man7.org/linux/man-pages/man7/user_namespaces.7.html\r\nhttps://docs.docker.com/engine/reference/commandline/dockerd/#daemon-user-namespace-options\r\nhttp://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.9",
          "title": "确保默认的cgroup使用情况已确认",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "--cgroup-parent选项允许您设置用于所有容器的默认cgroup父选项。如果没有特定的使用要求，则该设置应保留在默认状态。",
          "rationale": "系统管理员通常定义容器应该运行的cgroup。即使系统管理员没有明确定义cgroup，容器也默认在docker cgroup下运行。\r\n可以在默认的cgroup上增加其他cgroup，但是这种类型的用法应该被监控和确认，因为连接到默认的cgroup以外的其他cgroup，可能会共享资源不均匀，导致主机的资源利用率问题。",
          "audit": "为了确认此设置，应审查dockerd启动选项和/etc/docker/daemon.json中的任何设置。使用ps -ef | grep dockerd命令要查看dockerd启动选项\r\n您应该确保--cgroup-parent 参数要么未设置，要么设置为适当的非默认cgroup。还应针对此设置检查/etc/docker/daemon.json的内容。",
          "remediation": "默认设置符合良好的安全实践，可以保留。如果您想专门设置非默认cgroup，请在启动时将--cgroup-parent参数传递给Docker守护进程。例如：dockerd --cgroup-parent=/foobar",
          "impact": "无",
          "default_value": "默认情况下，docker守护进程使用/docker作为fs cgroup驱动程序，系统cgroup驱动程序使用system.slice。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#default-cgroup-parent",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.10",
          "title": "确保在需要之前不会更改基础设备大小",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "在某些情况下，您可能需要大于10G的容器。在适用的情况下，您应该仔细选择基础设备大小。",
          "rationale": "基础设备大小可以在守护进程重新启动时增加。增加基础设备大小允许所有未来的镜像和容器都达到新的基础设备大小。用户可以使用此选项来扩展基础设备大小，但不允许缩小。此值影响系统范围的“basic”空文件系统，该系统可能已经初始化，因此由拉取的镜像继承。\r\n虽然文件系统只要是空的，就不会分配增加的空间，但将为额外的镜像分配更多空间。如果分配的分区已满，这可能会导致拒绝服务条件。",
          "audit": "要确认此设置，应查看dockerd启动选项和/etc/docker/daemon.json中的任何设置。要查看dockerd启动选项，请使用ps -ef | grep dockerd命令。执行该命令后，不应该显示任何--storage-opt dm.basesize参数。还应审查/etc/docker/daemon.json的内容",
          "remediation": "在需要之前，请勿设置--storage-opt dm.basesize。",
          "impact": "无",
          "default_value": "默认基础设备大小为10G。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#storage-driver-options",
          "auto": true
        },
        {
          "id": "2.11",
          "title": "确保Docker客户端命令的授权认证已启用",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您应该使用本机Docker授权认证插件或带有Docker守护进程的第三方授权认证机制来管理对Docker客户端命令的访问。",
          "rationale": "Docker的开箱即用授权认证模式目前是“要么全有要么全无”。这意味着任何有权访问Docker守护进程的用户都可以运行任何Docker客户端命令。访问Docker API以访问守护进程的远程用户也是如此。如果您需要更大的访问控制，您可以创建授权认证插件并将其添加到Docker守护进程配置中。使用授权认证插件，Docker管理员可以配置粒度访问策略来管理对Docker守护进程的访问。\r\nDocker的第三方集成可以实现自己的授权认证模型，以要求在docker的本机授权插件之外使用Docker守护进程进行授权（即Kubernetes，Cloud Foundry，Openshift）。\r\n应该注意的是，本机Docker身份验证插件只是执行此控件的一种方法，因此在将其评估为审计的通过或失败之前，应审查可能正在使用的其他方法。",
          "audit": "要确认此设置，应查看dockerd启动选项和/etc/docker/daemon.json中的任何设置。要查看dockerd启动选项，请使用ps -ef | grep dockerd命令",
          "remediation": "步骤1：安装/创建授权插件。\r\n步骤2：根据需要配置授权策略。\r\n步骤3：启动docker守护进程如下：dockerd --authorization-plugin=<PLUGIN_ID>",
          "impact": "每个Docker命令都需要通过授权插件机制。这可能会对性能产生影响。或许可以使用不影响此性能的替代机制。",
          "default_value": "默认情况下，不会设置授权插件。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#access-authorization\r\nhttps://docs.docker.com/engine/extend/plugins_authorization/\r\nhttps://github.com/twistlock/authz",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.12",
          "title": "确保配置了集中和远程日志记录",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "Docker支持各种日志记录机制。存储日志的首选方法是支持集中和远程管理。",
          "rationale": "集中和远程日志记录确保所有重要的日志记录即使在出现重大数据可用性问题时也是安全的。Docker支持各种日志记录方法，您应该使用最适合您的IT安全策略的方法。",
          "audit": "运行docker info --format '{{ .LoggingDriver }}'命令，并确保 Logging Driver属性设置得合适。\r\n或者，执行ps -ef | grep dockerd命令获取--log-driver设置。如果已配置，您应该确保设置得当。对于此设置，还应查看/etc/docker/daemon.json的内容。",
          "remediation": "步骤1：按照文档设置所需的日志驱动程序。\r\n步骤2：使用该日志驱动程序启动docker守护进程。例如：dockerd --log-driver=syslog --log-opt syslog-address=tcp://192.xxx.xxx.xxx",
          "impact": "无",
          "default_value": "默认情况下，容器日志作为json文件维护",
          "references": "https://docs.docker.com/engine/admin/logging/overview/",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "2.13",
          "title": "确保禁用遗留仓库（v1）上的操作",
          "profile_application": "Level 1 - Docker",
          "description": "最新的Docker仓库是v2。传统仓库版本（v1）上的所有操作都应受到限制。",
          "rationale": "Docker仓库v2比v1带来了许多性能和安全改进。它支持容器镜像来源和其他安全功能，如映像签名和验证。因此，应该限制Docker遗留仓库的操作。",
          "audit": "ps -ef | grep dockerd命令应将--disable-legacy-registry列为传递给docker守护进程的选项。",
          "remediation": "启动docker守护进程如下：dockerd --disable-legacy-registry",
          "impact": "遗留的仓库操作将受到限制。",
          "default_value": "默认情况下，允许进行遗留仓库操作。",
          "references": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/#legacy-registries\r\nhttps://docs.docker.com/registry/spec/api/\r\nhttps://the.binbashtheory.com/creating-private-docker-registry-2-0-with-token-authentication-service/\r\nhttps://blog.docker.com/2015/07/new-tool-v1-registry-docker-trusted-registry-v2-open-source/\r\nhttp://www.slideshare.net/Docker/docker-registry-v2",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.14",
          "title": "确保已启用实时恢复",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "--live-restore选项可以在Docker中完全支持无守护进程容器。它确保Docker不会在关机或恢复时停止容器，并确保它在重新启动时正确地重新连接到容器。",
          "rationale": "重要的安全三要素是可用性。在Docker守护进程中设置--live-restore标志可确保容器执行在不可用时不会中断。这也使更新和修补Docker守护进程变得更容易，而无需应用程序停机。",
          "audit": "您应该运行docker info --format '{{ .LiveRestoreEnabled }}'命令，并确保启用Live Restore Enabled属性设置为true。\r\n或者，您可以运行ps -ef | grep dockerd命令，并确保--live-restore正在使用。还应审查/etc/docker/daemon.json的内容，以确保此设置到位。",
          "remediation": "在守护进程模式下运行Docker，并将--live-restore作为参数传递给它。例如，dockerd --live-restore",
          "impact": "无",
          "default_value": "默认情况下，--live-restore未启用。",
          "references": "https://docs.docker.com/engine/admin/live-restore/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.15",
          "title": "确保用户代理已禁用",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "每当端口暴露时，Docker守护进程都会启动用户代理服务进行端口转发。在提供环状NAT的地方，这项服务通常符合要求，并且可以禁用。",
          "rationale": "Docker引擎提供了环状NAT和使用用户代理两种机制，用于将端口从主机转发到容器。在大多数情况下，环状NAT模式是首选，因为它提高了性能，并使用了原生Linux iptables功能，而不是使用额外的组件。\r\n在环状NAT可用的地方，用户代理应在启动时禁用，以减少安装的攻击面。",
          "audit": "要确认此设置，您应该查看dockerd启动选项和/etc/docker/daemon.json中的任何设置。要查看dockerd启动选项，请使用：ps -ef | grep dockerd\r\n确保--userland-proxy参数设置为false。对于此设置，还应查看/etc/docker/daemon.json的内容。",
          "remediation": "您应该运行Docker守护进程：dockerd --userland-proxy=false",
          "impact": "一些具有旧Linux内核的系统可能无法支持环状NAT，因此需要用户代理服务。此外，一些网络设置可能会受到用户代理的删除的影响。",
          "default_value": "默认情况下，用户代理是启用的。",
          "references": "http://windsock.io/the-docker-proxy/\r\nhttps://github.com/docker/docker/issues/14856\r\nhttps://github.com/docker/docker/issues/22741\r\nhttps://docs.docker.com/engine/userguide/networking/default_network/binding/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.16",
          "title": "如果可以，请确保应用整个守护进程的自定义seccomp配置文件",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "如果需要，您可以选择覆盖Docker的默认seccomp配置文件在守护进程级别上应用自定义seccomp配置文件。",
          "rationale": "大量的系统调用暴露在每个用户进程中，其中许多在进程的整个生命周期内都没有使用。许多应用程序不需要所有这些系统调用，因此根据组织安全策略审查当前使用的每个系统调用会更好。减少一组系统调用减少了暴露在应用程序中的总内核表面，从而提高了应用程序安全性。\r\n可以应用自定义seccomp配置文件，而不是Docker的默认seccomp配置文件。如果Docker的默认配置文件适合您的环境，您可以选择忽略此建议。",
          "audit": "您应该运行下面的命令，并查看Security Options部分中列出的seccomp配置文件。如果是默认的，则表示应用了Docker的默认seccomp配置文件。docker info --format '{{ .SecurityOptions }}'",
          "remediation": "默认情况下，应用Docker的默认seccomp配置文件。如果这适合您的环境，则无需采取任何行动。如果您选择应用自己的seccomp配置文件，请在守护进程开始时使用--seccomp-profile标志，或将其放入守护进程运行时参数文件中:dockerd --seccomp-profile </path/to/seccomp/profile>",
          "impact": "配置错误的seccomp配置文件可能会中断您的容器环境。Docker默认阻止的调用已经过仔细审查，并解决了容器环境中的一些关键漏洞/问题（例如，内核循环调用）。因此，如果您选择覆盖默认设置，您应该格外小心。",
          "default_value": "默认情况下，Docker应用默认的seccomp配置文件。",
          "references": "https://docs.docker.com/engine/security/seccomp/\r\nhttps://github.com/docker/docker/pull/26276",
          "auto": true
        },
        {
          "id": "2.17",
          "title": "确保实验功能不在生产中使用",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "在生产中不应启用实验功能。",
          "rationale": "“Experimental”目前是一个运行时Docker守护进程标志，而不是单独构建的功能。将--experimental作为运行时标志传递给docker守护进程会激活实验功能。虽然“Experimental”被认为是一个稳定的版本，但它有一些功能，这些功能可能尚未经过全面测试，也不能保证API的稳定性。",
          "audit": "您应该运行docker version --format '{{ .Server.Experimental }}'命令，并确保在服务部分中将Experimental属性设置为false。",
          "remediation": "您不应该将--experimental作为运行时参数传递给生产系统上的Docker守护进程。",
          "impact": "无",
          "default_value": "默认情况下，Docker守护进程中不会激活实验功能。",
          "references": "https://docs.docker.com/edge/engine/reference/commandline/dockerd/#options",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "2.18",
          "title": "确保容器被限制获取新特权",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认情况下，您应该限制容器通过suid或sgid获得其他特权。",
          "rationale": "进程可以在内核中设置no_new_priv位，这在forks、clones和execve之间仍然存在。No_new_priv位确保进程及其子进程不会通过suid或sgid位获得任何额外的特权。这降低了与许多危险操作相关的安全风险，因为破坏特权二进制文件的能力大大降低。",
          "audit": "要确认此设置，您应该查看dockerd启动选项，并检查/etc/docker/daemon.json中的任何设置。要查看dockerd启动选项，可以使用ps -ef | grep dockerd命令您应该确保--no-new-privileges参数存在，并且它没有设置为false。\r\n还应审查/etc/docker/daemon.json的内容。",
          "remediation": "您应该这样运行Docker守护进程：dockerd --no-new-privileges",
          "impact": "no_new_priv阻止SELinux等LSMs升级单个容器的权限。",
          "default_value": "默认情况下，容器不受限制获取新权限。",
          "references": "https://github.com/moby/moby/pull/29984\r\nhttps://github.com/moby/moby/pull/20727\n",
          "auto": true,
          "level": "medium"
        }
      ]
    },
    {
      "id": "3",
      "title": "Docker守护进程配置文件",
      "description": "本节涵盖与Docker相关的文件以及目录权限和所有权。保持可能包含敏感参数的文件和目录的安全对于Docker守护进程的正确和安全运行非常重要。",
      "checks": [
        {
          "id": "3.1",
          "title": "确保docker.service文件所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证docker.service文件所有权和组所有权是否正确设置为root。",
          "rationale": "docker.service文件包含敏感参数，可能会改变Docker守护进程的行为。因此，它应该由root用户和用户组单独拥有，以确保它不会被特权较低的用户修改或损坏。",
          "audit": "步骤1：查找文件位置：systemctl show -p FragmentPath docker.service\r\n步骤2：如果文件不存在，则不适用此建议。如果文件存在，请执行stat -c %U:%G /usr/lib/systemd/system/docker.service | grep -v root:root命令（应使用正确的文件路径），以验证文件是否归root用户和用户组所有，该命令不应该返回任何东西。。",
          "remediation": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.service\r\n步骤2：如果文件不存在，则不适用此建议。如果文件确实存在，您应该执行chown root:root /usr/lib/systemd/system/docker.service命令（应使用正确的文件路径），以便将文件的所有权和组所有权设置为root。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统上，如果没有，则本建议不适用。默认情况下，如果文件存在，正确的权限是将所有权和组所有权设置为root。",
          "references": "https://docs.docker.com/engine/admin/systemd/",
          "auto": true,
          "level": "high"
        },
        {
          "id": "3.2",
          "title": "确保docker.service文件权限设置为644或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证docker.service文件权限是否设置为644或限制性更强的值。",
          "rationale": "docker.service文件包含敏感参数，可能会改变Docker守护进程的行为。因此，它不应该由root以外的任何其他用户写入，以确保它不能被特权较低的用户修改。",
          "audit": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.service\r\n步骤2：如果文件不存在，则不适用此建议。如果文件存在，请执行stat -c %a /usr/lib/systemd/system/docker.service命令（应使用正确的文件路径），以验证文件权限是否设置为644或更严格的值。",
          "remediation": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.service\r\n步骤2：如果文件不存在，则不适用此建议。如果文件存在，请执行chmod 644 /usr/lib/systemd/system/docker.service命令（应使用正确的文件路径，将文件权限设置为644。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统上。在这种情况下，这项建议不适用。默认情况下，如果文件存在，则文件权限已正确设置为644。",
          "references": "https://docs.docker.com/articles/systemd/",
          "auto": true,
          "level": "high"
        },
        {
          "id": "3.3",
          "title": "确保docker.socket文件所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证docker.socket文件所有权和组所有权是否正确设置为root。",
          "rationale": "docker.socket文件包含敏感参数，可能会改变Docker远程API的行为。因此，它应该由root用户和用户组拥有，以确保它不会被特权较低的用户修改。",
          "audit": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.socket\r\n步骤2：如果文件不存在，则不适用此建议。如果文件存在，请执行stat -c %U:%G /usr/lib/systemd/system/docker.socket | grep -v root:root命令（应使用正确的文件路径），以验证文件是否由root用户和用户组拥有。该命令不应返回值。",
          "remediation": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.socket\r\n步骤2：如果文件不存在，则不适用此建议。如果文件存在，请执行chown root:root /usr/lib/systemd/system/docker.socket命令（应使用正确的文件路径），以将文件的所有权和组所有权设置为root。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统上。在这种情况下，这项建议不适用。默认情况下，如果文件存在，则应将其所有权和组所有权设置为root。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option\r\nhttps://github.com/docker/docker-ce/blob/master/components/packaging/deb/systemd/docker.socket",
          "auto": true,
          "level": "high"
        },
        {
          "id": "3.4",
          "title": "确保docker.socket文件权限设置为644或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证docker.socket文件中的文件权限是否已正确设置为644或更严格。",
          "rationale": "docker.socket文件包含敏感参数，可能会改变Docker远程API的行为。因此，它应该只能由root写入，以确保它不会被特权较低的用户修改。",
          "audit": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.socket\r\n步骤2：如果文件不存在，则不适用此建议。如果文件存在，您应该执行stat -c %a /usr/lib/systemd/system/docker.socket命令（应使用正确的文件路径），以验证文件权限是否设置为644或更严格。",
          "remediation": "步骤1：找出文件位置：systemctl show -p FragmentPath docker.socket\r\n步骤2：如果文件不存在，则不适用此建议。如果文件确实存在，您应该执行chmod 644 /usr/lib/systemd/system/docker.socket命令（应使用正确的文件路径），将文件权限设置为644的正确文件路径。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统上，在这种情况下，本建议不适用。默认情况下，如果文件存在，则权限应设置为644或更严格。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket\r\nhttps://github.com/YungSang/fedora-atomic-packer/blob/master/oem/docker.socket\r\nhttp://daviddaeschler.com/2014/12/14/centos-7rhel-7-and-docker-containers-on-boot/",
          "auto": true,
          "level": "high"
        },
        {
          "id": "3.5",
          "title": "确保/etc/docker目录所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证/etc/docker目录所有权和组所有权是否正确设置为root。",
          "rationale": "除了其他各种敏感文件外，/etc/docker目录还包含证书和密钥。因此，它应该由root用户和用户组拥有，以确保它不能被特权较低的用户修改。",
          "audit": "您应该执行stat -c %U:%G /etc/docker | grep -v root:root命令，以验证目录是否归root用户和用户组所有。此命令不应返回任何数据。",
          "remediation": "要解决这个问题，您应该运行chown root:root /etc/docker命令，这会将目录的所有权和组所有权设置为root。",
          "impact": "无",
          "default_value": "默认情况下，此目录的所有权和组所有权已正确设置为root。",
          "references": "https://docs.docker.com/engine/security/https/\n",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.6",
          "title": "确保/etc/docker目录权限被限制设置为755或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证/etc/docker目录权限是否已正确设置为755或更严格。",
          "rationale": "除了各种敏感文件外，/etc/docker目录还包含证书和密钥。因此，它只能通过root写入，以确保它不能被特权较低的用户修改。",
          "audit": "您应该执行stat -c %a /etc/docker命令，以验证目录是否哦拥有755权限或严格。",
          "remediation": "您应该运行chmod 755 /etc/docker命令，这将目录的权限设置为755。",
          "impact": "无",
          "default_value": "默认情况下，此目录的权限设置为755。",
          "references": "https://docs.docker.com/engine/security/https/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.7",
          "title": "确保仓库证书文件所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证所有仓库证书文件（通常在/etc/docker/certs.d/<registry-name>目录下找到）均由root用户和用户组单独拥有",
          "rationale": "/etc/docker/certs.d/<registry-name>目录包含Docker仓库证书。这些证书文件必须由root用户和用户组单独拥有，以确保特权较低的用户无法修改目录的内容。",
          "audit": "您应该执行stat -c %U:%G /etc/docker/certs.d/* | grep -v root:root命令，以验证仓库证书文件是否由root用户和用户组单独拥有，该命令不应返回任何值。",
          "remediation": "可以执行chown root:root /etc/docker/certs.d/<registry-name>/*命令，这将把仓库证书文件的用户和用户组所有权设置为root。",
          "impact": "无",
          "default_value": "默认情况下，仓库证书文件的用户和用户组所有权正确设置为root。",
          "references": "https://docs.docker.com/registry/insecure/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.8",
          "title": "确保仓库证书文件权限设置为444或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证所有仓库证书文件（通常在/etc/docker/certs.d/<registry-name>目录下找到）的权限为444或设置更严格。",
          "rationale": "/etc/docker/certs.d/<registry-name>目录包含Docker仓库证书。这些证书文件必须具有444的权限或更具限制性的权限，以确保非特权用户无法完全访问它们。",
          "audit": "您应该执行stat -c %a /etc/docker/certs.d/<registry-name>/*命令，以验证仓库证书文件是否具有444的权限或设置了更严格的权限。",
          "remediation": "您应该执行chmod 444 /etc/docker/certs.d/<registry-name>/*命令。这将把仓库证书文件的权限设置为444。",
          "impact": "无",
          "default_value": "默认情况下，仓库证书文件的权限可能不是444。默认文件权限受操作系统本身定义的系统或用户特定的掩码值的约束。",
          "references": "https://docs.docker.com/registry/insecure/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.9",
          "title": "确保TLS CA证书文件所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证TLS CA证书文件（与--tlscacert参数一起传递的文件）是否由root用户和用户组单独所有。",
          "rationale": "TLS CA证书文件应受到保护，免受任何篡改。它用于根据给定的CA证书对Docker服务器进行身份验证。因此，它必须由root用户和用户组单独所有，以确保它不能被特权较低的用户修改。",
          "audit": "您应该执行stat -c %U:%G <path to TLS CA certificate file> | grep -v root:root命令，以验证TLS CA证书文件是否归root用户和用户组拥有。该命令不应返回任何结果。",
          "remediation": "您应该执行chown root:root <path to TLS CA certificate file>命令，这将TLS CA证书文件的用户和用户组所有权设置为root。",
          "impact": "无",
          "default_value": "默认情况下，TLS CA证书文件的用户和用户组已正确设置为root。",
          "references": "https://docs.docker.com/registry/insecure/\r\nhttps://docs.docker.com/engine/security/https/",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "3.10",
          "title": "确保将TLS CA证书文件权限设置为444或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证TLS CA证书文件（与--tlscacert参数一起传递的文件）的权限为444或设置更严格。",
          "rationale": "TLS CA证书文件应受到保护，免受任何篡改。它用于根据给定的CA证书对Docker服务器进行身份验证。因此，它必须具有444的权限，或更具限制性的权限，以确保权限较小的用户无法修改文件。",
          "audit": "您应该执行stat -c %a <path to TLS CA certificate file>命令，以验证TLS CA证书文件是否具有444的权限，或者这些权限设置了更严格的权限：",
          "remediation": "您应该执行chmod 444 <path to TLS CA certificate file>命令，这将TLS CA文件的文件权限设置为444。",
          "impact": "无",
          "default_value": "默认情况下，TLS CA证书文件的权限可能不是444。默认文件权限受操作系统或特定于用户的掩码值的约束。",
          "references": "https://docs.docker.com/registry/insecure/\r\nhttps://docs.docker.com/engine/security/https/",
          "auto": false
        },
        {
          "id": "3.11",
          "title": "确保Docker服务器证书文件所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证Docker服务器证书文件（与--tlscert参数一起传递的文件）是否为root用户和用户组所拥有的。",
          "rationale": "Docker服务器证书文件应受到保护，免受任何篡改。它用于根据给定的服务器证书对Docker服务器进行身份验证。因此，它必须由root用户和用户组单独拥有，以防止特权较低的用户进行修改。",
          "audit": "您应该执行stat -c %U:%G <path to Docker server certificate file> | grep -v root:root命令，以验证Docker服务器证书文件是否由root用户和用户组单独拥有，该命令不应返回任何结果。",
          "remediation": "您应该运行chown root:root <path to Docker server certificate file>命令，这将Docker服务器证书文件的用户和用户组所有权设置为root。",
          "impact": "无",
          "default_value": "默认情况下，Docker服务器证书文件的用户和用户组所有权已正确设置为root。",
          "references": "https://docs.docker.com/registry/insecure/\r\nhttps://docs.docker.com/engine/security/https/",
          "auto": false
        },
        {
          "id": "3.12",
          "title": "确保Docker服务器证书文件权限设置为444或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证Docker服务器证书文件（与--tlscert参数一起传递的文件）是否具有444个或更多限制性权限。",
          "rationale": "Docker服务器证书文件应受到保护，免受任何篡改。它用于根据给定的服务器证书对Docker服务器进行身份验证。因此，它应该有444的权限来防止其修改。",
          "audit": "您应该执行stat -c %a <path to Docker server certificate file>命令，以验证Docker服务器证书文件是否具有444或更多限制性权限：",
          "remediation": "您应该执行chmod 444 <path to Docker server certificate file>命令,这将Docker服务器证书文件的文件权限设置为444。",
          "impact": "无",
          "default_value": "默认情况下，Docker服务器证书文件的权限可能不是444。默认文件权限受操作系统或特定于用户的掩码值的约束。",
          "references": "https://docs.docker.com/registry/insecure/\r\nhttps://docs.docker.com/engine/security/https/",
          "auto": false
        },
        {
          "id": "3.13",
          "title": "确保Docker服务器证书密钥文件所有权设置为root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证Docker服务器证书密钥文件（与--tlskey参数一起传递的文件）是否为root用户和用户组所拥有的。",
          "rationale": "Docker服务器证书密钥文件应受到保护，免受任何篡改或不必要的读/写。由于它持有Docker服务器证书的私钥，因此它必须由root用户和用户组单独拥有，以确保特权较低的用户无法访问它。",
          "audit": "您应该执行stat -c %U:%G <path to Docker server certificate key file> | grep -v root:root命令，以验证Docker服务器证书密钥文件是否由root用户和用户组单独拥有，上面的命令不应该返回任何结果。",
          "remediation": "您应该执行chown root:root <path to Docker server certificate key file>命令，这将Docker服务器证书密钥文件的用户和用户组所有权设置为root。",
          "impact": "无",
          "default_value": "https://docs.docker.com/registry/insecure/\r\nhttps://docs.docker.com/engine/security/https/",
          "references": "",
          "auto": false
        },
        {
          "id": "3.14",
          "title": "确保Docker服务器证书密钥文件权限设置为400",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证Docker服务器证书密钥文件（与--tlskey参数一起传递的文件）是否具有400的权限。",
          "rationale": "Docker服务器证书密钥文件应受到保护，免受任何篡改或不必要的读取。它持有Docker服务器证书的私钥。因此，它必须具有400的权限，以确保证书密钥文件不会被修改。",
          "audit": "您应该执行stat -c %a <path to Docker server certificate key file>命令，以验证Docker服务器证书密钥文件是否具有400的权限：",
          "remediation": "您应该执行chmod 400 <path to Docker server certificate key file>命令，这将Docker服务器证书密钥文件权限设置为400。",
          "impact": "无",
          "default_value": "默认情况下，Docker服务器证书密钥文件的权限可能不是400。默认文件权限受操作系统或特定于用户的掩码值的约束。",
          "references": "https://docs.docker.com/registry/insecure/\r\nhttps://docs.docker.com/engine/security/https/",
          "auto": false
        },
        {
          "id": "3.15",
          "title": "确保Docker套接字文件所有权设置为root:docker",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证Docker套接字文件是否归root所有，用户组归docker所有。",
          "rationale": "Docker守护进程以root方式运行。因此，默认的Unix套接字必须归root所有。如果任何其他用户或进程拥有此套接字，则该非特权用户或进程可能会与Docker守护进程进行交互。此外，在这种情况下，非特权用户或进程可能能够与容器交互，这既不安全也不是理想行为。\r\n此外，Docker安装程序创建一个名为docker的Unix组。您可以将用户添加到此组中，在这种情况下，这些用户将能够读取和写入默认的Docker Unix套接字。Docker组的成员资格由系统管理员严格控制。然而，如果任何其他组都拥有此套接字，那么该组的成员可能会与Docker守护进程进行交互。这样的组可能不像docker组那样受到严格控制。同样，这不符合良好的安全实践。\r\n出于这些原因，默认的Docker Unix套接字文件应归root用户和docker用户组所拥有，以保持套接字文件的完整性。",
          "audit": "您应该执行stat -c %U:%G /var/run/docker.sock | grep -v root:docker命令，以验证Docker套接字文件是否归root用户和docker用户组所有，上面的命令不应该返回任何结果。",
          "remediation": "您应该执行chown root:docker /var/run/docker.sock命令，这为默认Docker套接字文件将所有权设置为root用户和docker用户组所拥有。",
          "impact": "无",
          "default_value": "默认情况下，Docker套接字文件的用户所有权和用户组所有权正确设置为root:docker。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option\r\nhttps://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.16",
          "title": "确保Docker套接字文件权限设置为660或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证Docker套接字文件是否具有660的权限或配置更严格。",
          "rationale": "只有root用户和docker组的用户才能读取和写入默认的Docker Unix套接字。因此，Docker套接字文件应具有660个或更多限制性的权限。",
          "audit": "您应该执行stat -c %a /var/run/docker.sock命令，以验证Docker套接字文件是否具有660个或更多限制性权限",
          "remediation": "你应该执行chmod 660 /var/run/docker.sock命令，这将Docker套接字文件的文件权限设置为660。",
          "impact": "无",
          "default_value": "默认情况下，Docker套接字文件的权限正确设置为660。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option\r\nhttps://docs.docker.com/engine/reference/commandline/dockerd/#bind-docker-to-another-hostport-or-a-unix-socket",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.17",
          "title": "确保 daemon.json 文件所有权设置为 root:root",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证daemon.json文件的用户和用户组权限是否正确设置为root。",
          "rationale": "Daemon.json文件包含敏感参数，可以改变docker守护进程的行为。因此，它应该由root用户和用户组所拥有，以确保它不能被特权较低的用户修改。",
          "audit": "您应该执行stat -c %U:%G /etc/docker/daemon.json | grep -v root:root命令，以验证文件是否归root用户和用户组所有，上面的命令不应返回任何结果。",
          "remediation": "您应该执行chown root:root /etc/docker/daemon.json命令，这将设置文件为root用户和用户组所拥有。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统中，在这种情况下，本建议不适用。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.18",
          "title": "确保daemon.json文件权限设置为644或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证daemon.json文件权限是否已正确设置为644或更严格。",
          "rationale": "daemon.json文件包含敏感参数，可能会改变docker守护进程的行为。因此，它应该只能由root写入，以确保它不会被特权较低的用户修改。",
          "audit": "您应该执行stat -c %a /etc/docker/daemon.json命令，以验证文件权限是否已正确设置为644或更严格：",
          "remediation": "您应该执行chmod 644 /etc/docker/daemon.json命令,这会将此文件的文件权限设置为644。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统中，在这种情况下，本建议不适用。",
          "references": "https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.19",
          "title": "确保/etc/default/docker文件所有权设置为root:root",
          "profile_application": "",
          "description": "您应该验证/etc/default/docker文件所有权和组所有权是否正确设置为root。",
          "rationale": "/etc/default/docker文件包含敏感参数，可能会改变Docker守护进程的行为。因此，它应该由root用户和用户组单独拥有，以确保它不能被特权较低的用户修改。",
          "audit": "您应该执行stat -c %U:%G /etc/default/docker | grep -v root:root命令，以验证文件是否由root用户和用户组单独拥有。该命令不应该返回任何结果。",
          "remediation": "您应该执行chown root:root /etc/default/docker命令，这将文件的所有权和组所有权设置为root。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统中，在这种情况下，本建议不适用。",
          "references": "https://docs.docker.com/engine/admin/configuring/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "3.20",
          "title": "确保/etc/default/docker文件权限设置为644或更严格",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该验证/etc/default/docker文件权限是否已正确设置为644或更严格。",
          "rationale": "/etc/default/docker文件包含敏感参数，可能会改变Docker守护进程的行为。因此，它应该只能由root写入，以确保它不会被特权较低的用户修改。",
          "audit": "您应该执行stat -c %a /etc/default/docker命令，以验证文件权限是否已正确设置为644或更严格。",
          "remediation": "您应该执行以下命令：chmod 644 /etc/default/docker，这会将此文件的文件权限设置为644。",
          "impact": "无",
          "default_value": "此文件可能不存在于系统上，在这种情况下，本建议不适用。",
          "references": "https://docs.docker.com/engine/admin/configuring/",
          "auto": true,
          "level": "medium"
        }
      ]
    },
    {
      "id": "4",
      "title": "容器镜像和构建文件配置",
      "description": "容器基于镜像和管理特定镜像中的容器实例行为的构建文件。确保您使用正确的基础镜像和构建文件，这对于构建容器化基础设施非常重要。以下是您应该对容器基础镜像和构建文件遵循的一些建议，以确保您的容器化基础设施是安全的。",
      "checks": [
        {
          "id": "4.1",
          "title": "确保已为容器创建用户",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "容器应作为非root用户运行。",
          "rationale": "在可能的情况下，作为非root用户运行容器是良好做法。这可以通过Dockerfile中的USER指令或gosu等类似方式完成，如果用作CMD或ENTRYPOINT指令的一部分。",
          "audit": "您应该运行docker ps --quiet | xargs --max-args=1 -I{} docker exec {} cat /proc/1/status | grep '^Uid:' | awk '{print $3}'命令，这应该返回每个容器的有效UID，当它返回0时，它表示容器进程作为root运行。",
          "remediation": "您应该确保每个容器镜像的Dockerfile包含以下信息：USER <username or ID>，在这种情况下，用户名或ID是指在容器基本镜像中找到的用户。如果容器基础镜像中没有创建特定用户，则使用useradd命令在Dockerfile中的USER指令之前添加特定用户。例如，在Dockerfile中添加以下行，以便在容器中创建用户：RUN useradd -d /home/username -m -s /bin/bash username\r\nUSER username\r\n注意：如果镜像中有不需要的用户，您应该考虑删除它们。删除这些用户后，提交镜像，然后生成容器的新实例。\r\n或者，如果无法在Dockerfile中设置USER指令，则应使用作为Dockerfile的CMD或ENTRYPOINT部分的一部分运行的脚本来确保容器进程切换到非root用户。",
          "impact": "作为非root用户运行可能会带来一些困难，即您希望从底层主机绑定挂载卷。在这种情况下，应注意确保运行所包含进程的用户可以根据他们的要求读取和写入绑定目录。",
          "default_value": "默认情况下，容器使用root 特权运行，并且也作为容器中的root用户运行。",
          "references": "https://github.com/docker/docker/issues/2918\r\nhttps://github.com/docker/docker/pull/4572\r\nhttps://github.com/docker/docker/issues/7906",
          "auto": true,
          "level": "high"
        },
        {
          "id": "4.2",
          "title": "确保容器仅使用受信任的基本镜像",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该确保您使用的容器镜像要么从头开始编写，要么基于通过安全通道下载的另一个已建立和受信任的基础镜像。",
          "rationale": "官方存储库包含由Docker社区或其供应商策划和优化的Docker镜像。不能保证这些镜像是安全的，并且不包含安全漏洞或恶意代码。因此，在从Docker和第三方获取容器镜像时应谨慎行事，并应根据组织安全政策审查运行这些镜像。",
          "audit": "您应该通过执行docker images命令来查看主机上存在哪些Docker镜像，此命令列出了目前可用于Docker主机的所有容器镜像。然后，您应该根据组织的安全政策查看每个镜像的来源并查看其内容。您可以使用docker history <imageName>命令查看向镜像提交历史记录。",
          "remediation": "以下程序有助于建立对特定镜像的信任。\r\n1.配置和使用Docker内容信任。\r\n2.查看每个Docker镜像的历史记录，以评估其风险，具体取决于您希望使用它部署的应用程序的灵敏度。\r\n3.定期扫描Docker镜像以查找漏洞。",
          "impact": "无",
          "default_value": "不适用",
          "references": "https://titanous.com/posts/docker-insecurity\r\nhttps://registry.hub.docker.com/\r\nhttp://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/\r\nhttps://github.com/docker/docker/issues/8093\r\nhttps://docs.docker.com/engine/reference/commandline/pull/\r\nhttps://github.com/docker/docker/pull/11109\r\nhttps://blog.docker.com/2015/11/docker-trusted-registry-1-4/",
          "auto": false
        },
        {
          "id": "4.3",
          "title": "确保容器中没有安装不必要的软件包",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "容器的体积应尽可能小，并且不应包含不必要的软件包，这可能会增加其攻击面。",
          "rationale": "不必要的软件不应该安装到容器中，因为这样做会增加它们的攻击面。只应安装正确运行所部署应用程序所必需的软件包。",
          "audit": "步骤1：通过执行docker ps --quiet命令列出容器的所有运行实例\r\n步骤2：对于每个容器实例，执行docker exec $INSTANCE_ID rpm -qa命令，该命令列出了安装的软件包。您应该查看列表，并确保实际需要安装的所有内容。\r\n",
          "remediation": "您不应该在容器中安装任何不需要的东西。如果可以的话，您应该考虑使用最小的基本镜像，而不是标准的Redhat/Centos/Debian镜像。一些可用的选项包括BusyBox和Alpine这不仅可以大大缩小您的镜像大小，而且可能包含攻击向量的软件也会更少。",
          "impact": "无",
          "default_value": "不适用",
          "references": "https://docs.docker.com/userguide/dockerimages/\r\nhttp://www.livewyer.com/blog/2015/02/24/slimming-down-your-docker-containers-alpine-linux\r\nhttps://github.com/progrium/busybox",
          "auto": false
        },
        {
          "id": "4.4",
          "title": "确保镜像经过扫描和重建，以包含安全补丁",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "应经常扫描镜像以查找任何漏洞。您应该重建所有镜像以包含这些补丁，然后从中实例化新容器。",
          "rationale": "漏洞是黑客或恶意用户可以利用的漏洞或错误，安全补丁是解决这些漏洞的更新。镜像漏洞扫描工具可用于查找镜像中的漏洞，然后检查可用的补丁以缓解这些漏洞。补丁将系统更新到不包含这些问题的最新代码库，并且处于代码库的支持版本非常重要，因为供应商往往不会为不再支持的旧版本提供补丁。在应用之前，应评估安全补丁，并应根据组织的IT安全政策实施补丁。",
          "audit": "步骤1：通过执行docker ps --quiet命令列出容器的所有运行实例\r\n步骤2：对于每个容器实例，请使用容器中的软件包管理器（假设有一个可用的）来检查安全补丁的可用性。或者，运行镜像漏洞评估工具来扫描环境中的所有镜像。\r\n",
          "remediation": "应重镜像，确保使用最新版本的基本镜像，以将操作系统补丁级别保持在适当的级别。重新构建镜像后，应利用更新的镜像重新启动容器。",
          "impact": "无",
          "default_value": "默认情况下，容器和镜像不会自动更新以解决丢失的操作系统安全补丁。",
          "references": "https://docs.docker.com/userguide/dockerimages/\r\nhttps://docs.docker.com/docker-cloud/builds/image-scan/\r\nhttps://blog.docker.com/2016/05/docker-security-scanning/\r\nhttps://docs.docker.com/engine/reference/builder/#/onbuild",
          "auto": false
        },
        {
          "id": "4.5",
          "title": "确保Docker的内容信任已启用",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "默认情况下，内容信任被禁用，应根据组织安全策略启用。",
          "rationale": "内容信任提供了对发送到远程Docker仓库和从远程Docker仓库接收的数据使用数字签名的能力。这些签名允许客户端验证特定镜像标签的身份和发布者，并确保容器镜像的来源。",
          "audit": "您应该执行echo $DOCKER_CONTENT_TRUST命令，这应该返回1的值。",
          "remediation": "要在bash shell中启用内容信任，您应该输入export DOCKER_CONTENT_TRUST=1命令，或者，您可以在你的配置文件中设置此环境变量，以便在每次登录时启用内容信任。",
          "impact": "在设置DOCKER_CONTENT_TRUST的环境中，您需要遵循信任程序，同时使用与镜像相关的命令-build、create、pull、push和run。您可以使用--disable-content-trust标志根据需要对没有内容信任的标记镜像运行单个操作，但这违背了启用内容信任的目的，因此应尽可能避免。\r\n注意：内容信任目前仅适用于公共Docker Hub的用户。它目前不适用于Docker受信任仓库或仓库。",
          "default_value": "默认情况下，内容信任被禁用。",
          "references": "https://docs.docker.com/engine/security/trust/content_trust/\r\nhttps://docs.docker.com/engine/reference/commandline/cli/#notary\r\nhttps://docs.docker.com/engine/reference/commandline/cli/#environment-variables",
          "auto": true,
          "level": "high"
        },
        {
          "id": "4.6",
          "title": "确保健康检查说明已添加到容器镜像中",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该将HEALTHCHECK指令添加到Docker容器镜像中，以确保对正在运行的容器执行运行状况检查。",
          "rationale": "一个重要的安全控制是可用性。将HEALTHCHECK指令添加到容器镜像中可确保Docker引擎定期根据该指令检查正在运行的容器实例，以确保容器仍在运行。",
          "audit": "您应该运行docker inspect --format='{{ .Config.Healthcheck }}' <IMAGE>命令，以确保Docker镜像配置了适当的HEALTHCHECK指令。",
          "remediation": "您应该遵循Docker文档并重建容器镜像，以包含HEALTHCHECK指令。",
          "impact": "无",
          "default_value": "默认情况下，没有设置HEALTHCHECK。",
          "references": "https://docs.docker.com/engine/reference/builder/#healthcheck",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "4.7",
          "title": "确保更新说明不在Dockerfile中单独使用",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您不应单独或在Dockerfile中的一行中使用操作系统包管理器更新说明，如apt-get update 或yum update。",
          "rationale": "在Dockerfile上的一行中添加更新说明将导致更新层被缓存。然后，当您稍后使用相同的指令构建任何镜像时，这将导致使用之前缓存的更新层，这可能会阻止任何新的更新应用于以后的构建。",
          "audit": "步骤1：运行docker images命令以获取镜像列表：\r\n步骤2：对照上面列表中的每个镜像运行docker history <Image_ID>命令，查找包含在一行中的任何更新说明：\r\n",
          "remediation": "在安装软件包时，您应该使用更新说明以及安装说明和版本固定。这可以防止缓存，并强制提取所需的版本。\r\n或者，您可以在docker构建过程中使用--no-cache标志，以避免使用缓存层。",
          "impact": "无",
          "default_value": "默认情况下，Docker不会对使用更新说明实施任何限制。",
          "references": "https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#run\r\nhttps://github.com/docker/docker/issues/3313",
          "auto": false
        },
        {
          "id": "4.8",
          "title": "确保删除setuid和setgid权限",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "删除镜像中的setuid和setgid权限可以防止容器中的特权升级攻击。",
          "rationale": "setuid和setgid权限可用于权限升级。虽然这些权限有时是合法的，但您应该考虑从不需要它们的软件包中删除它们。这应该针对每个镜像进行审查。",
          "audit": "您应该对每个镜像运行docker run <Image_ID> find / -perm /6000 -type f -exec ls -ld {} \\; 2> /dev/null命令，以列出具有setuid或setgid权限的可执行文件。\r\n然后，您应该查看列表，并确保使用这些权限配置的所有可执行文件实际上都需要它们。",
          "remediation": "您应该只对需要的可执行文件允许setuid和setgid权限。您可以通过在Dockerfile中添加以下命令在构建时删除这些权限，最好是在Dockerfile的末尾：RUN find / -perm /6000 -type f -exec chmod a-s {} \\; || true",
          "impact": "上述命令将破坏所有依赖于setuid或setgid权限的可执行文件，包括合法权限。因此，您应该小心修改命令以适应您的要求，这样它就不会过度减少合法程序的权限。因此，在进行此类修改之前，您应该保持一定程度的谨慎，并仔细检查所有流程，以避免中断。",
          "default_value": "不适合",
          "references": "http://www.oreilly.com/webops-perf/free/files/docker-security.pdf\r\nhttp://container-solutions.com/content/uploads/2015/06/15.06.15_DockerCheatSheet_A2.pdf\r\nhttp://man7.org/linux/man-pages/man2/setuid.2.html\r\nhttp://man7.org/linux/man-pages/man2/setgid.2.html",
          "auto": false
        },
        {
          "id": "4.9",
          "title": "确保在Dockerfiles中使用COPY而不是ADD",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该在Dockerfile中使用COPY指令而不是ADD指令。",
          "rationale": "COPY指令只需将文件从本地主机复制到容器文件系统。ADD指令可能会从远程URL检索文件，并执行解压等操作。因此，ADD指令引入了安全风险。例如，恶意文件可以直接从URL访问，而无需扫描，或者可能存在与解压它们相关的漏洞。",
          "audit": "步骤1：运行docker images命令以获取镜像列表\r\n步骤2：对照上面列表中的每个镜像运行以下命令，并查找任何ADD说明：docker history <Image_ID>，或者，如果您可以访问镜像的Dockerfile，则应验证是否有ADD指令。\r\n",
          "remediation": "您应该在Dockerfiles中使用COPY而不是ADD指令。",
          "impact": "如果应用程序需要作为ADD指令一部分的功能，例如，如果您需要从远程URL检索文件，则需要注意实现此控件。",
          "default_value": "不适合",
          "references": "https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy",
          "auto": false
        },
        {
          "id": "4.10",
          "title": "确保机密不存储在Dockerfile中",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "不要在Dockerfiles中存储任何机密。",
          "rationale": "Docker镜像并不不透明，包含有关用于构建它们的命令的信息。因此，这些秘密不应包含在用于构建镜像的Docker文件中，因为它们对镜像的任何用户都是可见的。",
          "audit": "步骤1：运行docker images命令以获取镜像列表：\r\n步骤2：为上面列表中的每个镜像运行docker history <Image_ID>命令，并查找任何机密。或者，如果您可以访问镜像的Dockerfile，请验证没有上述秘密。\r\n",
          "remediation": "不要在Dockerfiles中存储任何类型的机密。如果构建过程中需要机密，请使用机密管理工具，例如Docker中包含的buildkit构建器。",
          "impact": "Docker镜像构建需要适当的秘密管理流程。",
          "default_value": "默认情况下，对在Dockerfiles中存储配置密钥没有限制。",
          "references": "https://github.com/docker/docker/issues/13490\r\nhttp://12factor.net/config\r\nhttps://avicoder.me/2016/07/22/Twitter-Vine-Source-code-dump/\r\nhttps://docs.docker.com/develop/develop-images/build_enhancements/",
          "auto": false
        },
        {
          "id": "4.11",
          "title": "确保仅安装经过验证的软件包",
          "profile_application": " Level 2 - Docker - Linux",
          "description": "在将软件包安装到镜像中之前，您应该验证它们的真实性。",
          "rationale": "验证软件包的真实性对于构建安全的容器镜像至关重要。没有已知来源的软件包可能是恶意的或具有可以利用的漏洞。",
          "audit": "步骤1：运行docker images命令以获取镜像列表：\r\n步骤2：为上面列表中的每个镜像运行docker history <Image_ID>命令，并检查如何确定软件包的真实性。这可以通过使用GPG密钥或其他安全软件包分发机制。\r\n或者，如果您可以访问该镜像的Dockerfile，请验证是否已检查软件包的真实性。",
          "remediation": "您应该使用您选择的安全软件包分发机制来确保软件包的真实性。",
          "impact": "无",
          "default_value": "不适合",
          "references": "http://www.oreilly.com/webops-perf/free/files/docker-security.pdf\r\nhttps://github.com/docker-library/httpd/blob/12bf8c8883340c98b3988a7bade8ef2d0d6dcf8a/2.4/Dockerfile\r\nhttps://github.com/docker-library/php/blob/d8a4ccf4d620ec866d5b42335b699742df08c5f0/7.0/alpine/Dockerfile\r\nhttps://access.redhat.com/security/team/key",
          "auto": false
        }
      ]
    },
    {
      "id": "5",
      "title": "容器运行时配置",
      "description": "容器的启动方式涉及许多安全影响。可以提供一些具有安全因素的运行时参数，这些参数可能会损害主机和在上面运行的容器。因此，验证容器的启动方式以及哪些参数与它们相关联非常重要。应根据组织安全策略审查容器运行时配置。",
      "checks": [
        {
          "id": "5.1",
          "title": "确保（如果适用）启用了AppArmor配置文件",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "AppArmor是一个有效且易于使用的Linux应用程序安全系统。默认情况下，它在某些Linux发行版上可用，例如在Debian和Ubuntu上。",
          "rationale": "AppArmor通过执行也称为AppArmor配置文件的安全策略来保护Linux操作系统和应用程序免受各种威胁。您可以为容器创建自己的AppArmor配置文件或使用Docker的默认配置文件。启用此功能将对配置文件中定义的容器执行安全策略。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: AppArmorProfile={{ .AppArmorProfile }}'命令，此命令应为每个容器实例返回有效的AppArmor配置文件。",
          "remediation": "如果AppArmor适用于您的Linux操作系统，您应该启用它。\r\n1.验证是否安装了AppArmor。\r\n2.为Docker容器创建或导入AppArmor配置文件。\r\n3.实现政策的执行。\r\n4.使用自定义的AppArmor配置文件启动Docker容器。例如：docker run --interactive --tty --security-opt=\"apparmor:PROFILENAME\" ubuntu /bin/bash。或者，可以使用Docker的默认AppArmor策略。",
          "impact": "容器将具有AppArmor配置文件中定义的安全控制。应该注意的是，如果AppArmor配置文件配置错误，这可能会导致容器的操作问题。",
          "default_value": "默认情况下，docker-default AppArmor配置文件应用于正在运行的容器。此配置文件可以在/etc/apparmor.d/docker上找到。",
          "references": "https://docs.docker.com/engine/security/apparmor/\r\nhttps://docs.docker.com/engine/reference/run/#security-configuration\r\nhttps://docs.docker.com/engine/security/security/#other-kernel-security-features",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.2",
          "title": "如果适用，请确保设置SELinux安全选项",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "SELinux是一个有效且易于使用的Linux应用程序安全系统。默认情况下，它在某些发行版上可用，如Red Hat和Fedora。",
          "rationale": "SELinux提供了一个强制性访问控制（MAC）系统，大大增强了默认的自由支配访问控制（DAC）模型。因此，您可以通过在Linux主机上启用SELinux，为容器添加额外的安全层。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'命令，此命令返回当前在列出的容器上配置的所有安全选项。",
          "remediation": "如果SELinux适用于您的Linux操作系统，您应该使用它。\r\n1.设置SELinux状态。\r\n2.设置SELinux策略。\r\n3.为Docker容器创建或导入SELinux策略模板。4.在启用SELinux的守护进程模式下启动Docker。例如：docker daemon --selinux-enabled。\r\n5.使用安全选项启动Docker容器。例如，docker run --interactive --tty --security-opt label=level:TopSecret centos /bin/bash\r\n或者，可以使用Docker的默认AppArmor策略。docker run --interactive --tty --security-opt=\"apparmor:PROFILENAME\" ubuntu /bin/bash",
          "impact": "容器将具有AppArmor配置文件中定义的安全控制。应该注意的是，如果AppArmor配置文件配置错误，这可能会导致容器的操作问题。",
          "default_value": "默认情况下，docker-default AppArmor配置文件应用于正在运行的容器。此配置文件可以在/etc/apparmor.d/docker上找到。",
          "references": "https://docs.docker.com/engine/security/apparmor/\r\nhttps://docs.docker.com/engine/reference/run/#security-configuration\r\nhttps://docs.docker.com/engine/security/security/#other-kernel-security-features",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.3",
          "title": "确保容器内的Linux内核功能受到限制",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认情况下，Docker启动具有一组受限Linux内核功能的容器。这意味着任何进程都可以被授予所需的功能，而不是赋予其root访问权限。使用Linux内核功能，进程通常不需要作为root用户运行。",
          "rationale": "SELinux提供了一个强制性访问控制（MAC）系统，大大增强了默认的自由支配访问控制（DAC）模型。因此，您可以通过在Linux主机上启用SELinux，为容器添加额外的安全层。\r\n具体来说，在Docker提供的默认功能集中，如果没有明确要求，则应删除NET_RAW功能，因为它可以让有权访问容器的攻击者创建伪造的网络流量。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CapAdd={{ .HostConfig.CapAdd }} CapDrop={{ .HostConfig.CapDrop }}'命令。验证添加和删除的Linux内核功能是否与每个容器实例中容器进程所需的功能一致。具体来说，如果需要，请确保删除NET_RAW功能。",
          "remediation": "您应该执行docker run --cap-add={\"Capability 1\",\"Capability 2\"} <Run arguments> <Container Image Name or ID> <Command>命令来添加所需的功能。\r\n您应该执行docker run --cap-drop={\"Capability 1\",\"Capability 2\"} <Run arguments> <Container Image Name or ID> <Command>命令来删除不需要的功能。\r\n或者，您可以删除所有当前配置的功能，然后仅恢复您专门使用的功能：docker run --cap-drop=all --cap-add={\"Capability 1\",\"Capability 2\"} <Run arguments> <Container Image Name or ID> <Command>",
          "impact": "对容器内进程的限制基于哪些Linux功能生效。删除NET_RAW功能可以防止容器创建原始套接字，这在大多数情况下都是良好的安全实践，但可能会影响一些网络实用程序。",
          "default_value": "默认情况下，以下功能应用于容器：AUDIT_WRITE\nCHOWN\nDAC_OVERRIDE\nFOWNER\nFSETID\nKILL\nMKNOD\nNET_BIND_SERVICE\nNET_RAW\nSETFCAP\nSETGID\nSETPCAP\nSETUID\nSYS_CHROOT",
          "references": "https://docs.docker.com/engine/security/security/#linux-kernel-capabilities\r\nhttp://man7.org/linux/man-pages/man7/capabilities.7.html\r\nhttp://www.oreilly.com/webops-perf/free/files/docker-security.pdf",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.4",
          "title": "确保不使用特权容器",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "使用--privileged标志为其应用的容器提供所有Linux内核功能，因此覆盖--cap-add和--cap-drop标志。因此，您应该确保不使用它。",
          "rationale": "--privileged 标志为应用它的容器提供了所有功能，并解除了设备cgroup控制器实施的所有限制。因此，容器拥有基础主机的大部分权利。此标志仅用于允许特定用例（例如在Docker中运行Docker），通常不应使用。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Privileged={{ .HostConfig.Privileged }}'命令,上述命令应该为每个容器实例返回Privileged=false。",
          "remediation": "您不应该运行带有--privileged 标志的容器。例如，不要使用docker run --interactive --tty --privileged centos /bin/bash命令启动容器。",
          "impact": "如果您在没有--privileged标志的情况下启动容器，它不会具有过多的默认功能。",
          "default_value": "无",
          "references": "https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities",
          "auto": true,
          "level": "high"
        },
        {
          "id": "5.5",
          "title": "确保敏感的主机系统目录没有安装在容器上",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您不应该允许以下列出的敏感主机系统目录作为容器卷挂载，特别是在读写模式下。/\n/boot\n/dev\n/etc\n/lib\n/proc\n/sys\n/usr",
          "rationale": "如果敏感目录以读写模式挂载，则可以对其中的文件进行更改。这具有明显的安全影响，应该避免。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Volumes={{ .Mounts }}'命令。此命令返回当前映射目录的列表，并指示它们是否以每个容器实例的读写模式挂载。",
          "remediation": "您不应该在容器中对主机安装安全敏感的目录，特别是在读写模式下。",
          "impact": "无",
          "default_value": "Docker默认使用读写卷，但您也可以挂载只读目录。默认情况下，容器中不会安装敏感的主机目录。",
          "references": "https://docs.docker.com/engine/tutorials/dockervolumes/",
          "auto": true,
          "level": "high"
        },
        {
          "id": "5.6",
          "title": "确保sshd不在容器中运行",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "SSH守护进程不应在容器中运行。您应该SSH进入Docker主机，并使用docker exec进入容器。",
          "rationale": "在容器中运行SSH增加了安全管理的复杂性：\r\n难以管理SSH服务器的访问策略和安全合规性\r\n难以管理跨各种容器的密钥和密码\r\n难以管理SSH服务器的安全升级。可以在不使用SSH的情况下对容器进行shell访问，因此应避免不必要的增加安全管理的复杂性。",
          "audit": "步骤1：通过执行docker ps --quiet命令列出容器的所有运行实例\r\n步骤2：对于每个容器实例，执行docker exec $INSTANCE_ID ps -el命令\r\n确保SSH服务器没有流程。",
          "remediation": "从容器中卸载SSH守护进程，并使用docker exec --interactive --tty $INSTANCE_ID sh在远程主机上输入容器，或者docker attach $INSTANCE_ID",
          "impact": "无",
          "default_value": "默认情况下，SSH服务器不在容器内运行。每个容器只允许一个进程。",
          "references": "http://blog.docker.com/2014/06/why-you-dont-need-to-run-sshd-in-docker/",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.7",
          "title": "确保特权端口没有映射到容器中",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "1024以下的TCP/IP端口号被视为特权端口。出于各种安全原因，普通用户和进程不允许使用它们。然而，Docker确实允许将容器端口映射到特权端口。",
          "rationale": "默认情况下，如果用户没有将容器端口专门声明为主机端口映射，Docker会自动正确地将容器端口映射到主机上49153-65535范围内可用的容器端口。然而，如果用户明确声明，Docker确实允许将容器端口映射到主机上的特权端口。这是因为容器使用NET_BIND_SERVICE Linux内核功能执行，该功能不限制特权端口映射。特权端口接收和传输各种安全敏感的数据，允许容器使用这些数据不符合良好的安全实践。",
          "audit": "您可以通过执行docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'命令列出所有正在运行的容器实例及其端口映射。然后，您应该查看列表，并确保容器端口没有映射到1024以下的主机端口号。",
          "remediation": "启动容器时，您不应该将容器端口映射到特权主机端口。您还应该确保Dockerfile中没有这样的容器来托管特权端口映射声明。",
          "impact": "无",
          "default_value": "默认情况下，允许将容器端口映射到主机上的特权端口\r\n注意：在某些情况下，您可能想要映射特权端口，因为如果您禁止它，那么相应的应用程序必须在容器之外运行。\r\n例如：HTTP和HTTPS负载均衡器必须分别绑定80/tcp和443/tcp。禁止映射特权端口实际上禁止在容器中运行这些端口，并强制使用外部负载均衡器。在这种情况下，这些容器实例应标记为本建议的例外情况。",
          "references": "https://docs.docker.com/engine/userguide/networking/",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.8",
          "title": "确保容器上只有所需的端口是打开的",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "容器镜像的dockerfile定义了容器实例上默认打开的端口。端口列表与您在容器中运行的应用程序相关，只有在需要时才应打开。",
          "rationale": "容器只能使用Dockerfile中为其镜像定义的端口运行，也可以任意传递运行时参数以打开端口列表。此外，随着时间的推移，Dockerfile可能会经历各种更改，暴露端口的列表可能仍然与您在容器中运行的应用程序相关，也可能不相关。打开不需要的端口会增加容器和相关容器化应用程序的攻击面。良好的安全实践是仅打开应用程序正确运行所需的端口。",
          "audit": "您应该通过执行docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'命令来列出容器的所有运行实例及其关联的端口映射。然后，您应该查看列表，并确保每个容器确实需要映射的所有端口。",
          "remediation": "您应该确保每个容器镜像的Dockerfile仅公开所需的端口。您还可以在启动容器时不使用-P（UPPERCASE）或--publish-all标志，完全忽略Dockerfile中定义的端口列表。相反，请使用-p（小写）或--publish标志来显式定义特定容器实例所需的端口。例如：docker run --interactive --tty --publish 5000 --publish 5001 --publish 5002 centos /bin/bash",
          "impact": "无",
          "default_value": "默认情况下，当容器使用-P或--publish-all标志运行时，Dockerfile中在镜像的EXPOSE指令下列出的所有端口都会打开。",
          "references": "https://docs.docker.com/engine/userguide/networking/",
          "auto": false
        },
        {
          "id": "5.9",
          "title": "确保主机的网络命名空间未共享",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "当容器上的网络模式设置为--net=host时，容器不会放置在单独的网络堆栈中。实际上，应用此选项会指示Docker不要容器化容器的网络。其结果是，容器“外部”位于主Docker主机中，并可以完全访问其网络接口。",
          "rationale": "选择此选项可能很危险。它允许容器进程以任何其他root进程的方式打开保留的低编号端口。它还允许容器访问Docker主机上的D-bus等网络服务。容器进程可能会执行不必要的操作，例如关闭Docker主机。除非有非常具体的原因启用它，否则不应使用此选项。",
          "audit": "您应该使用docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: NetworkMode={{ .HostConfig.NetworkMode }}'命令，如果这返回NetworkMode=host，则表示在容器启动时传递了--net=host选项。",
          "remediation": "启动任何容器时，您不应传递--net=host选项。",
          "impact": "无",
          "default_value": "默认情况下，容器在启动时连接到Docker桥接，并且不会在主机网络堆栈的上下文中运行。",
          "references": "https://docs.docker.com/engine/userguide/networking/\r\nhttps://docs.docker.com/engine/reference/run/#network-settings",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.10",
          "title": "确保容器的内存使用受到限制",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认情况下，Docker主机上的所有容器均等地共享资源。通过使用Docker主机的资源管理功能，您可以控制容器能够使用的内存量。",
          "rationale": "默认情况下，容器可以使用主机上的所有内存。您可以使用内存限制机制来防止当一个容器消耗主机的所有资源而同一主机上的其他容器因此无法运行时发生拒绝服务。对内存使用没有限制可能会导致一个容器很容易使整个系统不稳定并因此无法使用的问题。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Memory={{ .HostConfig.Memory }}'命令。如果此命令返回0，则表示内存限制没有到位；如果它返回非零值，则表示它们已到位。",
          "remediation": "通过使用--memory参数，您应该只运行所需的尽可能多的内存来运行容器。例如，您可以使用以下命令运行容器：docker run --interactive --tty --memory 256m centos /bin/bash。在此示例中，容器的内存限制为256 MB。请注意，如果内存限制到位，以下命令的输出将返回科学符号的值：docker inspect --format='{{.Config.Memory}}' 7c5a2d4c7fe0\r\n例如，如果容器实例的内存限制设置为256 MB，则上述命令的输出将是2.68435456e+08，而不是256m。您应该使用科学计算器转换此值。",
          "impact": "如果每个容器上没有设置正确的内存限制，一个进程可以扩展其使用范围，并导致其他容器耗尽资源。",
          "default_value": "默认情况下，Docker主机上的所有容器均等地共享其资源，并且不执行内存限制。",
          "references": "https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/\r\nhttps://docs.docker.com/engine/reference/commandline/run/#options\r\nhttps://docs.docker.com/engine/admin/runmetrics/",
          "auto": true
        },
        {
          "id": "5.11",
          "title": "确保在容器上正确设置CPU优先级",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认情况下，Docker主机上的所有容器均等地共享资源。通过使用Docker主机的资源管理功能，您可以控制容器可能消耗的主机CPU资源。",
          "rationale": "默认情况下，CPU时间在容器之间平均分配。如果您希望控制容器实例中的可用CPU资源，您可以使用CPU共享功能。CPU共享允许您将一个容器优先于其他容器，并防止低优先级容器吸收其他进程可能需要的CPU资源。这确保了高优先级容器能够声明所需的CPU运行时。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CpuShares={{ .HostConfig.CpuShares }}'命令。如果上述命令返回0或1024，则表示CPU共享没有到位。如果它返回1024以外的非零值，则表示它们已经到位。",
          "remediation": "您应该根据容器在组织中的优先级来管理容器之间的CPU运行时。为此，请使用--cpu-shares参数启动容器。例如，您可以运行以下容器：docker run --interactive --tty --cpu-shares 512 centos /bin/bash\r\n在上面的示例中，容器从其他容器使用的50%的CPU份额开始。因此，如果另一个容器的CPU份额为80%，则该容器的CPU份额为40%。默认情况下，每个新容器都将有1024个CPU共享。但是，如果您运行审计部分中提到的命令，此值将显示为0。\r\n或者：\r\n1.导航到/sys/fs/cgroup/cpu/system.slice/目录。\r\n2.使用docker ps检查您的容器实例ID。\r\n3.在上面的目录（在第1步中），您可以调用一个目录，对于示例：docker-<Instance ID>.scope。例如，docker-4acae729e8659c6be696ee35b2237cc1fe4edd2672e9186434c5116e1a6fbed6.scope。导航到此目录。\r\n如果您将一个容器的CPU共享设置为512，它将获得与其他容器相比一半的CPU时间。因此，如果您将1024作为100%，那么您可以导出您应该为各自的CPU共享设置的数字。例如，如果您想将其设置为50%，请使用512，如果您想将其设置为25%，请使用256。",
          "impact": "如果您没有正确分配CPU阈值，容器进程可能会耗尽资源并变得无响应。如果主机上的CPU资源不受限制，CPU共享不会对单个资源施加任何限制。",
          "default_value": "默认情况下，Docker主机上的所有容器均等地共享其资源。没有强制执行CPU共享。",
          "references": "https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/\r\nhttps://docs.docker.com/engine/reference/commandline/run/#options\r\nhttps://docs.docker.com/engine/admin/runmetrics/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.12",
          "title": "确保容器的root文件系统已装载为只读",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "使用docker run的 --read-only选项，容器的root文件系统应被视为“黄金镜像”。这可以防止在容器运行时对容器的root文件系统进行任何写入，并执行不可变基础设施的原则。",
          "rationale": "启用此选项会强制容器在运行时明确定义其数据写入策略以持久化或不持久化其数据。这也减少了安全攻击向量，因为容器实例的文件系统不能被篡改或写入，除非其文件系统文件夹和目录上有明确的读写权限。",
          "audit": "您应该在docker主机上运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: ReadonlyRootfs={{ .HostConfig.ReadonlyRootfs }}'命令，如果上述命令返回true，则表示容器的root文件系统已挂载只读。如果上述命令返回false，则表示容器的root文件系统是可写的。",
          "remediation": "您应该在容器的运行时添加 --read-only 标志，以强制将容器的root文件系统挂载为只读。docker run <Run arguments> --read-only <Container Image Name or ID> <Command>\r\n管理员应在容器运行时启用--read-only 选项来强制容器的可执行进程在其生命周期内仅将容器数据写入显式存储位置。\r\n容器运行期间显式存储位置的示例包括但不限于：\r\n1.使用--tmpfs选项为非持久数据写入挂载临时文件系统:docker run --interactive --tty --read-only --tmpfs \"/run\" --tmpfs \"/tmp\" centos /bin/bash\r\n2.启用Docker rw挂载在容器的运行时，以将容器数据直接保留在Docker主机文件系统上:docker run --interactive --tty --read-only -v /opt/app/data:/run/app/data:rw centos /bin/bash\r\n3.使用Docker数据卷的Docker共享存储卷插件来持久化容器数据。docker volume create -d convoy --opt o=size=20GB my-named-volume\ndocker run --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash\r\n3.在容器运行时将容器数据传输到Docker控制区域之外的容器数据，以确保其持久性。示例包括托管数据库、网络文件共享和API。",
          "impact": "如果没有定义数据写入策略，在容器运行时启用--read-only 可能会破坏一些容器操作系统包。您应该定义容器的数据在运行时应该和不应该保留什么，以便决定使用哪种策略。例如：启用使用--tmpfs进行临时文件写入/tmp，使用Docker共享数据卷进行持久数据写入",
          "default_value": "默认情况下，容器具有可写的root文件系统，允许所有容器进程写入容器实际运行时用户拥有的文件。",
          "references": "http://docs.docker.com/reference/commandline/cli/#run\r\nhttps://docs.docker.com/engine/tutorials/dockervolumes/\r\nhttp://www.projectatomic.io/blog/2015/12/making-docker-images-write-only-in-production/\r\nhttps://docs.docker.com/engine/reference/commandline/run/#mount-tmpfs-tmpfs\t\nhttps://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container",
          "auto": true,
          "level": "high"
        },
        {
          "id": "5.13",
          "title": "确保传入的容器流量绑定到特定的主机接口",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认情况下，Docker容器可以连接到外部世界，但外部世界无法连接到容器，每个传出连接似乎都来自主机自己的IP地址之一。您只应允许通过主机上的特定外部接口联系容器服务。",
          "rationale": "如果您的主机上有多个网络接口，容器可以接受任何网络接口上裸露端口上的连接。这可能不可取，也可能不安全。在许多情况下，外部暴露了特定、所需的接口，入侵检测、入侵预防、防火墙、负载平衡等服务都是故意在那里运行的，以筛选传入的公共流量。因此，您不应该接受任何随机接口上的传入连接，而只接受为此类流量指定的连接。",
          "audit": "您应该通过执行docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Ports={{ .NetworkSettings.Ports }}'命令列出容器及其端口映射的所有运行实例。\r\n然后查看列表，并确保暴露的容器端口绑定到特定的接口，而不是通配符IP地址-0.0.0.0。\r\n例如，如果上面的命令返回以下结果，这是不合规的，并且容器可以在指定端口49153上接受任何主机接口上的连接。Ports=map[443/tcp:<nil> 80/tcp:[map[HostPort:49153 HostIp:0.0.0.0]]]\r\n但是，如果公开的端口绑定到主机上的特定接口，如下所示，则根据良好的安全实践进行配置。Ports=map[443/tcp:<nil> 80/tcp:[map[HostIp:10.2.3.4 HostPort:49153]]]",
          "remediation": "您应该将容器端口绑定到所需主机端口上的特定主机接口。例如:docker run --detach --publish 10.2.3.4:49153:80 nginx。在上面的示例中，容器端口80绑定到49153上的主机端口，并且仅接受来自10.2.3.4外部接口的传入连接。",
          "impact": "无",
          "default_value": "默认情况下，Docker在0.0.0.0上公开容器端口，该通配符IP地址将匹配主机上任何可能的传入网络接口。",
          "references": "https://docs.docker.com/engine/userguide/networking/",
          "auto": true,
          "level": "high"
        },
        {
          "id": "5.14",
          "title": "确保“故障”容器重新启动策略设置为“5”",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "通过使用docker run命令中的--restart标志，您可以为容器在退出时应该或不应该重新启动指定重新启动策略。您应该选择on-failure故障重启策略，并将重新启动尝试限制为5。",
          "rationale": "如果您无限期地继续尝试启动容器，可能会导致主机拒绝服务。这可能是进行分布式拒绝服务攻击的简单方法，特别是如果您在同一台主机上有很多容器。此外，忽略容器的退出状态并始终试图重新启动容器，导致无法调查容器终止的根本原因。如果容器被终止，您应该调查其背后的原因，而不仅仅是试图无限期重新启动它。您应该使用故障重启策略将容器重新启动次数限制在最多5次尝试。",
          "audit": "您应该使用docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: RestartPolicyName={{ .HostConfig.RestartPolicy.Name }} MaximumRetryCount={{ .HostConfig.RestartPolicy.MaximumRetryCount }}'命令，如果此命令始终返回RestartPolicyName=always，则系统配置不理想。\r\n如果上述命令返回RestartPolicyName=no或仅返回RestartPolicyName=，则不会使用重新启动策略，容器永远不会自动重新启动。虽然这可能是一个安全的选项，但从可用性的角度来看，它不是最佳选择。\r\n如果上述命令返回RestartPolicyName=on-failure，则通过查看MaximumRetryCount来验证重新启动尝试次数是否设置为5次或更少。",
          "remediation": "如果您希望容器自动重新启动，示例命令如下：docker run --detach --restart=on-failure:5 nginx",
          "impact": "如果设置了此选项，容器只会尝试重新启动5次。",
          "default_value": "默认情况下，容器没有配置重新启动策略。",
          "references": "https://docs.docker.com/engine/reference/commandline/run/#restart-policies-restart",
          "auto": true
        },
        {
          "id": "5.15",
          "title": "确保主机的进程命名空间不共享",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "进程ID（PID）命名空间隔离进程ID空间，这意味着不同PID命名空间中的进程可以具有相同的PID。这在容器和主机之间创建了进程级隔离。",
          "rationale": "PID命名空间提供了进程之间的分离。它防止系统进程可见，并允许重复使用进程ID，包括PID 1。如果主机的PID命名空间与容器共享，它基本上将允许它们查看主机系统上的所有进程。这降低了主机和容器之间进程级隔离的好处。在这种情况下，有权访问容器的恶意用户可以访问主机本身的进程，操纵它们，甚至能够杀死它们。这可能会允许主机本身被关闭，这可能非常严重，特别是在多租户环境中。您不应该与主机上运行的容器共享主机的进程命名空间。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: PidMode={{ .HostConfig.PidMode }}'命令,如果上述命令返回host，则表示主机PID命名空间与其容器共享；任何其他结果都意味着系统是按照良好的安全实践配置的。",
          "remediation": "您不应该使用--pid=host参数启动容器。例如，不要使用以下命令启动容器：docker run --interactive --tty --pid=host centos /bin/bash",
          "impact": "容器进程无法在主机系统上看到进程。在某些情况下，您可能希望容器共享主机的进程命名空间。例如，您可以构建一个包含strace或gdb等调试工具的容器，并希望在主机上调试进程时使用这些工具。如果需要，请使用-p开关共享特定的主机进程。docker run --pid=host rhel7 strace -p 1234",
          "default_value": "默认情况下，所有容器都启用了PID命名空间，因此主机的进程命名空间不会与其容器共享。",
          "references": "https://docs.docker.com/engine/reference/run/#pid-settings-pid\r\nhttp://man7.org/linux/man-pages/man7/pid_namespaces.7.html",
          "auto": true,
          "level": "critical"
        },
        {
          "id": "5.16",
          "title": "确保主机的IPC命名空间不共享",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "IPC（POSIX/SysV IPC）命名空间提供命名共享内存段、信号量和消息队列的分离。因此，主机上的IPC命名空间不应与容器共享，而应保持隔离状态。",
          "rationale": "IPC命名空间提供了主机和容器之间的IPC分离。如果主机的IPC命名空间与容器共享，它将允许容器内的进程查看主机系统上的所有IPC通信。这将消除主机和容器之间IPC级别隔离的好处。有权访问容器的攻击者可以访问此级别的主机，并产生重大后果。因此，IPC命名空间不应在主机及其容器之间共享。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: IpcMode={{ .HostConfig.IpcMode }}'命令，如果命令返回host，则表示主机IPC命名空间与容器共享。任何其他结果都意味着它没有被共享，因此系统是按照良好的安全实践配置的。",
          "remediation": "您不应该使用--ipc=host参数启动容器。例如，不要启动以下容器：docker run --interactive --tty --ipc=host centos /bin/bash",
          "impact": "共享内存段用于加速进程间通信，通常在高性能应用程序中。如果此类应用程序被容器化为多个容器，您可能需要共享容器的IPC命名空间，以便实现高性能。在这种情况下，您仍然应该只共享特定于容器的IPC命名空间，而不是主机IPC命名空间。容器的IPC命名空间可以与另一个容器共享，如下所示：docker run --interactive --tty --ipc=container:e3a7a1a97c58 centos /bin/bash",
          "default_value": "默认情况下，所有容器都启用了IPC命名空间，主机IPC命名空间不会与任何容器共享。",
          "references": "https://docs.docker.com/engine/reference/run/#ipc-settings-ipc\r\nhttp://man7.org/linux/man-pages/man7/namespaces.7.html",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.17",
          "title": "确保主机设备不会直接暴露在容器中",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "在运行时，主机设备可以直接暴露在容器中。不要直接将主机设备暴露给容器，特别是不受信任的容器。",
          "rationale": " --device选项将主机设备暴露在容器中，因此容器可以直接访问这些设备。容器不需要以特权模式运行即可访问和操作它们，因为默认情况下，容器被授予此类访问权限。此外，容器可以从主机中删除块设备。因此，您不应该将主机设备直接暴露在容器中。\r\n如果您出于某种原因希望将主机设备暴露到容器中，您应该根据您的组织逐案考虑您希望在案例上使用哪些共享权限：r - read only\r\nw - writable\r\nm - mknod allowed",
          "audit": "您应该使用docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Devices={{ .HostConfig.Devices }}'命令，上述命令将列出包含以下信息的每台设备：CgroupPermissions - 例如，rwm\r\nPathInContainer - 容器内的设备路径\r\nPathOnHost-主机上的设备路径\r\n您应该验证需要从容器中访问主机设备，以及所需的权限是否已正确设置。如果上述命令返回[]，则容器无法访问主机设备，并按照良好的安全实践进行配置。",
          "remediation": "您不应该直接将主机设备暴露在容器中。如果您确实需要将主机设备暴露在容器中，您应该根据您的组织使用粒度权限。例如，不要使用docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rwm -- device=/dev/temp_sda:/dev/temp_sda:rwm centos bash命令启动容器。您只能使用适当的权限共享主机设备：docker run --interactive --tty --device=/dev/tty0:/dev/tty0:rw -- device=/dev/temp_sda:/dev/temp_sda:r centos bash",
          "impact": "您将无法直接在容器中使用主机设备。",
          "default_value": "默认情况下，主机设备不会暴露在容器中。如果您不提供共享权限，并选择将主机设备暴露给容器，则主机设备将通过read、write和mknod权限公开。",
          "references": "https://docs.docker.com/engine/reference/commandline/run/#options",
          "auto": false
        },
        {
          "id": "5.18",
          "title": "如果需要，请确保在运行时覆盖默认限制",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "默认ulimit设置在Docker守护进程级别。但是，如果您需要，您可以在容器运行时覆盖默认的ulimit设置。",
          "rationale": "ulimit提供对shell及其启动的进程可用的资源的控制。以谨慎的方式设置系统资源限制，防止拒绝服务条件。有时，合法用户和进程可能会意外过度使用系统资源，导致系统退化甚至无响应。\r\nDocker守护进程级别的默认ulimit集应该得到遵守。如果默认的ulimit设置不适合特定的容器实例，您可以作为例外覆盖它们，但这不应该例行进行。如果您的许多容器实例超出了您的ulimit设置，您应该考虑将默认设置更改为更适合您需求的设置。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Ulimits={{ .HostConfig.Ulimits }}'命令，除非在特定情况下需要覆盖默认设置，否则此命令应为每个容器实例返回Ulimits=<no value>。",
          "remediation": "只有在特定情况下需要时，您才应该覆盖默认的ulimit设置。例如，要覆盖默认的ulimit设置，请启动以下容器：docker run --ulimit nofile=1024:1024 --interactive --tty centos /bin/bash",
          "impact": "如果ulimits设置不正确，单个容器的过度使用可能会使主机系统无法使用。",
          "default_value": "容器实例继承在Docker守护进程级别设置的默认ulimit设置。",
          "references": "https://docs.docker.com/engine/reference/commandline/run/#set-ulimits-in-container-ulimit\r\nhttp://www.oreilly.com/webops-perf/free/files/docker-security.pdf",
          "auto": false
        },
        {
          "id": "5.19",
          "title": "确保挂载传播模式未设置为共享",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "挂载传播模式允许在容器上以共享、从属或私有模式挂载卷。除非明确需要，否则不要使用共享挂载传播模式。",
          "rationale": "共享挂载在所有挂载上复制，在任何挂载点所做的更改都会传播到所有其他挂载点。在共享模式下装载卷不会限制任何其他容器安装和更改该卷。由于从安全角度来看，这可能不是一个理想的选项，除非明确要求，否则不应使用此功能。",
          "audit": "docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Propagation={{range $mnt := .Mounts}} {{json $mnt.Propagation}} {{end}}'\r\n上述命令返回已挂载卷的传播模式。除非需要，否则不应将传播模式设置为shared。如果没有挂载，上述命令可能会抛出错误。在这种情况下，这项建议不适用。",
          "remediation": "不要以共享模式传播方式装载宗卷。例如，不要启动以下容器：docker run <Run arguments> --volume=/hostPath:/containerPath:shared<Container Image Name or ID> <Command>",
          "impact": "无",
          "default_value": "默认情况下，容器挂载点是私有的。",
          "references": "https://docs.docker.com/storage/bind-mounts/#configure-bind-propagation\r\nhttps://docs.docker.com/engine/reference/run/#volume-shared-filesystems\r\nhttps://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.20",
          "title": "确保主机的UTS命名空间没有共享",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "UTS命名空间在两个系统标识符之间提供隔离：主机名和NIS域名。它用于设置在该命名空间中运行进程可见的主机名和域。在容器中运行的进程通常不需要知道主机名或域名。因此，UTS命名空间不应与主机共享。",
          "rationale": "与主机共享UTS命名空间为每个容器提供了更改主机主机名的完全权限。这不符合良好的安全实践，不应该被允许。",
          "audit": "您应该运行以下命令：docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: UTSMode={{ .HostConfig.UTSMode }}'\r\n如果上述命令返回host，则表示主机UTS命名空间与容器共享，并且此建议不符合要求。如果上述命令不返回任何内容，则主机的UTS命名空间不会共享。然后，此建议是符合要求的。",
          "remediation": "您不应该使用--uts=host参数启动容器。例如，不要使用这样的命令启动容器：docker run --rm --interactive --tty --uts=host rhel7.2",
          "impact": "无",
          "default_value": "默认情况下，所有容器都启用了UTS命名空间，主机UTS命名空间不与任何容器共享。",
          "references": "https://docs.docker.com/engine/reference/run/#uts-settings-uts\r\nhttp://man7.org/linux/man-pages/man7/namespaces.7.html",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.21",
          "title": "确保默认的seccomp配置文件未禁用",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "Seccomp过滤为进程提供了为传入的系统调用指定过滤器的方法。默认的Docker seccomp配置文件在白名单的基础上工作，并允许大量常见的系统调用，同时阻止所有其他调用。除非对容器应用程序的使用造成问题，否则不应禁用此过滤。",
          "rationale": "大量的系统调用暴露在每个用户区进程中，其中许多在进程的整个生命周期内都未使用。大多数应用程序不需要所有这些系统调用，因此将受益于减少一组可用的系统调用。减少一组系统调用可以减少暴露在应用程序中的整个内核表面，从而提高应用程序安全性。",
          "audit": "您应该运行以下命令：docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'\r\n这应该返回<no value>或您修改后的seccomp配置文件。如果它返回[seccomp:unconfined]，则容器运行时没有任何seccomp配置文件，因此没有按照良好的安全实践进行配置。",
          "remediation": "默认情况下，seccomp配置文件是启用的。除非您想修改和使用修改后的seccomp配置文件，否则您不需要做任何事情。",
          "impact": "使用Docker 1.10及更高版本，默认的seccomp配置文件会阻止syscalls，无论使用--cap-add传递给容器。在这种情况下，您应该创建自己的自定义seccomp配置文件。您也可以通过在docker run上传递--security-opt=seccomp:unconfined来禁用默认的seccomp配置文件。",
          "default_value": "当您运行容器时，它使用默认配置文件，除非您使用--security-opt选项覆盖它。",
          "references": "http://blog.scalock.com/new-docker-security-features-and-what-they-mean-seccomp-profiles\r\nhttps://docs.docker.com/engine/reference/run/#security-configuration\r\nhttps://github.com/docker/docker/blob/master/profiles/seccomp/default.json\r\nhttps://docs.docker.com/engine/security/seccomp/\r\nhttps://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt\r\nhttps://github.com/docker/docker/issues/22870",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.22",
          "title": "确保docker exec命令不与特权选项一起使用",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您不应该将docker exec与--privileged选项一起使用。",
          "rationale": "在docker exec命令中使用--privileged选项为该命令提供扩展的Linux功能。这可能是一种不安全的做法，特别是当您运行功能减少或限制增强的容器时。",
          "audit": "如果您按照第1节的建议启用了审计，您可以使用ausearch -k docker | grep exec | grep privileged命令过滤掉使用--privileged选项的docker exec命令。",
          "remediation": "您不应该在docker exec命令中使用--privileged选项。",
          "impact": "如果您需要在容器中增强功能，请使用所需的所有权限运行它。这些应该单独指定。",
          "default_value": "默认情况下，docker exec命令在没有--privileged选项的情况下运行。",
          "references": "https://docs.docker.com/engine/reference/commandline/exec/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.23",
          "title": "确保docker exec命令不与user=root选项一起使用",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您不应该将docker exec与--user=root选项一起使用。",
          "rationale": "使用docker exec命令中的--user=root选项，作为root用户在容器中执行它。这可能不安全，特别是当您运行功能减少或增强限制的容器时。",
          "audit": "如果您已按照第1节的建议启用审计，您可以使用ausearch -k docker | grep exec | grep user命令过滤掉使用--user=root选项的docker exec命令。",
          "remediation": "您不应该在docker exec命令中使用--user=root选项。",
          "impact": "无",
          "default_value": "默认情况下，docker exec命令在没有--user选项的情况下运行。",
          "references": "https://docs.docker.com/engine/reference/commandline/exec/\r\n",
          "auto": true
        },
        {
          "id": "5.24",
          "title": "确保确认cgroup使用情况",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "当容器实例化时，可以连接到特定的cgroup。确认cgroup的使用将确保容器在定义的cgroup中运行。",
          "rationale": "系统管理员通常定义应该运行容器的cgroup。如果系统管理员没有明确定义cgroup，则默认情况下，容器在docker cgroup中运行。\r\n在运行时，可以将容器附加到最初定义的cgroup以外的其他cgroup。这种用法应该得到监控和确认，因为通过附加到不同的cgroup，可能会向容器授予多余的权限和资源，因此这可能会被证明是一种安全风险。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: CgroupParent={{ .HostConfig.CgroupParent }}'命令,上面的命令返回正在运行容器的cgroup。如果是空的，这意味着容器在默认的docker cgroup下运行。任何其他返回值都表示系统配置不符合良好的安全实践。",
          "remediation": "除非严格要求，否则您不应在docker run命令中使用--cgroup-parent选项。",
          "impact": "无",
          "default_value": "默认情况下，容器在docker cgroup下运行。",
          "references": "https://docs.docker.com/engine/reference/run/#specify-custom-cgroups\r\nhttps://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "5.25",
          "title": "确保容器被限制获取其他特权。",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该限制容器通过suid或sgid位获得其他特权。",
          "rationale": "进程可以在内核中设置no_new_priv位，这在fork、clone和execve之间仍然存在。No_new_priv位确保进程及其子进程不会通过suid或sgid位获得任何额外的特权。这减少了与许多操作相关的危险，因为破坏特权二进制文件的可能性降低了。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: SecurityOpt={{ .HostConfig.SecurityOpt }}'命令，此命令应返回当前为容器配置的所有安全选项。no-new-privileges 特权应是其中之一。",
          "remediation": "您应该使用docker run --rm -it --security-opt=no-new-privileges ubuntu bash选项启动容器。",
          "impact": "no_new_priv选项阻止SELinux等LSM允许进程获得新特权",
          "default_value": "默认情况下，新权限不受限制。",
          "references": "https://github.com/projectatomic/atomic-site/issues/269\r\nhttps://github.com/docker/docker/pull/20727\r\nhttps://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt\r\nhttps://lwn.net/Articles/475678/\r\nhttps://lwn.net/Articles/475362/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.26",
          "title": "确保在运行时检查容器运行状况",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "如果容器镜像没有定义HEALTHCHECK指令，您应该在容器运行时使用--health-cmd参数来检查容器运行状况。",
          "rationale": "如果您使用的容器镜像没有预定义的HEALTHCHECK指令，请使用--health-cmd参数在运行时检查容器运行状况。根据报告的健康状况，必要时可以采取补救行动。",
          "audit": "您应该运行docker ps --quiet | xargs docker inspect --format '{{ .Id }}: Health={{ .State.Health.Status }}'命令，并确保所有容器都报告其运行状况：",
          "remediation": "您应该使用--health-cmd参数运行容器。例如:docker run -d --health-cmd='stat /etc/passwd || exit 1' nginx",
          "impact": "无",
          "default_value": "默认情况下，健康检查不会在容器运行时进行。",
          "references": "https://docs.docker.com/engine/reference/run/#healthcheck\r\n",
          "auto": false,
          "level": "medium"

        },
        {
          "id": "5.27",
          "title": "确保Docker命令始终使用最新版本的镜像",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该始终确保您使用的是存储库中最新版本的镜像，而不是缓存旧版本。",
          "rationale": "已知多个Docker命令，如docker pull、docker run等存在这样的问题。就是，默认情况下，它们会提取镜像的本地副本（如果有的话），即使上游存储库中有具有相同标签的镜像的更新版本。这可能导致使用包含已知漏洞的旧镜像。",
          "audit": "您应该完成以下步骤：：步骤1：打开您的镜像仓库，并列出您正在检查的镜像的镜像版本历史记录。\r\n步骤2：观察触发docker pull命令时的状态。如果状态显示为镜像是最新的，则表示您将获得镜像的缓存版本。\r\n步骤3：将您正在运行的镜像版本与仓库中报告的最新版本匹配，这将告诉您是运行缓存版本还是最新版本。",
          "remediation": "您应该使用适当的版本固定机制（默认分配的“latest”标签仍然容易受到缓存攻击），以避免提取缓存的旧版本。版本固定机制应用于基本镜像、软件包和整个镜像。您可以根据自己的要求自定义版本固定规则。",
          "impact": "无",
          "default_value": "默认情况下，Docker命令提取本地副本，除非使用版本固定机制或清除本地缓存。",
          "references": "https://github.com/docker/docker/pull/16609",
          "auto": false
        },
        {
          "id": "5.28",
          "title": "确保使用PIDs cgroup限制",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该在容器运行时使用--pids-limit标志。",
          "rationale": "攻击者可以在容器内用单个命令发射fork炸弹。这个fork炸弹可能会撞毁整个系统，需要重新启动主机才能使系统恢复正常运行。使用PIDs cgroup参数--pids-limit将通过限制在指定时间范围内容器内可能发生的fork数量来防止此类攻击。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: PidsLimit={{ .HostConfig.PidsLimit }}'命令，并确保PidsLimit没有设置为0或-1。0或-1的PidsLimit意味着任何数量的进程都可以在容器内同时fork。",
          "remediation": "启动容器时，使用具有适当值的--pids-limit标志。例如：docker run -it --pids-limit 100 <Image_ID>\r\n在上面的示例中，允许在任何给定时间运行的进程数量设置为100个。在达到100个并发运行的进程限制后，Docker将限制任何新的进程创建。",
          "impact": "酌情设置PID限制值。错误的值可能会导致容器无法使用。",
          "default_value": "--pids-limit的默认值为0，这意味着fork数量没有限制。请注意，PIDs cgroup限制仅适用于内核版本4.3及更高版本。",
          "references": "https://github.com/docker/docker/pull/18697\r\nhttps://docs.docker.com/engine/reference/commandline/run/#options",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.29",
          "title": "确保不使用Docker的默认桥接器“docker0”",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您不应该使用Docker的默认桥接docker0。相反，您应该使用Docker用户定义的网络进行容器网络。",
          "rationale": "Docker将桥接模式下创建的虚拟接口连接到名为docker0的普通桥接器。这种默认网络模型容易受到ARP欺骗和MAC泛滥攻击的影响，因为它没有应用过滤。",
          "audit": "您应该运行docker network ls --quiet | xargs docker network inspect --format '{{ .Name }}: {{ .Options }}'命令，并验证容器是否在用户定义的网络上，而不是默认的docker0桥接器",
          "remediation": "您应该遵循Docker文档并设置用户定义的网络。所有容器都应该在这个网络中运行。",
          "impact": "用户定义的网络需要根据组织安全策略进行配置和管理。",
          "default_value": "默认情况下，Docker在默认的docker0桥接器中运行容器。",
          "references": "https://github.com/nyantec/narwhal\r\nhttps://arxiv.org/pdf/1501.02967\r\nhttps://docs.docker.com/engine/userguide/networking/",
          "auto": true
        },
        {
          "id": "5.30",
          "title": "确保主机的用户名空间不共享",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您不应该与运行主机上的容器共享主机的用户命名空间。",
          "rationale": "用户命名空间确保容器内的root进程将映射到容器外的非root进程。因此，与容器共享主机的用户命名空间不会将主机上的用户与容器中的用户隔离开来。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: UsernsMode={{ .HostConfig.UsernsMode }}'命令，并确保它不会返回UsernsMode的任何值。如果它返回主机的值，则意味着主机用户命名空间与其容器共享。",
          "remediation": "您不应该在主机和容器之间共享用户命名空间。例如，您不应该运行以下命令：docker run --rm -it --userns=host ubuntu bash",
          "impact": "无",
          "default_value": "默认情况下，除非启用用户命名空间支持，否则主机用户命名空间与容器共享。",
          "references": "https://docs.docker.com/engine/security/userns-remap/\r\nhttps://docs.docker.com/engine/reference/commandline/run/#options\r\nhttps://github.com/docker/docker/pull/12648\r\nhttps://events.linuxfoundation.org/sites/events/files/slides/User%20Namespaces%20-%20ContainerCon%202015%20-%2016-9-final_0.pdf",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "5.31",
          "title": "确保Docker socket没有安装在任何容器中",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "Docker套接字docker.sock不应安装在容器中。",
          "rationale": "如果Docker socket安装在容器中，则可以允许在容器中运行的进程执行Docker命令，从而有效地允许完全控制主机。",
          "audit": "您应该运行docker ps --quiet --all | xargs docker inspect --format '{{ .Id }}: Volumes={{ .Mounts }}' | grep docker.sock命令,这将返回docker.sock作为卷映射到容器的任何实例。",
          "remediation": "您应该确保没有容器将docker.sock作为卷挂载。",
          "impact": "无",
          "default_value": "默认情况下，docker.sock没有安装在容器中。",
          "references": "https://raesene.github.io/blog/2016/03/06/The-Dangers-Of-Docker.sock/\r\nhttps://forums.docker.com/t/docker-in-docker-vs-mounting-var-run-docker-sock/9450/2\r\nhttps://github.com/docker/docker/issues/21109",
          "auto": true,
          "level": "medium"
        }
      ]
    },
    {
      "id": "6",
      "title": "Docker安全操作",
      "description": "本节涵盖与Docker部署相关的一些操作安全问题。这些是尽可能遵循的最佳做法。本节中的大多数建议只是提醒组织，组织应扩展其当前的安全最佳实践和政策，以包括容器。",
      "checks": [
        {
          "id": "6.1",
          "title": "确保避免镜像无序扩张",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "您不应该在同一台主机上保留大量容器镜像。酌情只使用带标签的镜像。",
          "rationale": "如果您需要在生产中从“latest”版本退回到特定版本的镜像，标记镜像非常有用。带有未使用或旧标签的镜像可能包含漏洞，如果实例化，可能会被利用。",
          "audit": "步骤1：列出当前实例化的所有镜像ID，方法是执行docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'命令\r\n步骤2：通过执行docker images命令列出系统上的所有镜像：\r\n步骤3：比较步骤1和步骤2中的镜像ID列表，并查找当前未使用的镜像。如果发现任何未使用或旧镜像，请与系统管理员讨论将此类镜像保存在系统上的必要性。如果不再需要镜像，则应将其删除。",
          "remediation": "您应该只保留您实际需要的，并建立一个工作流程来从主机中删除旧的或过时的镜像。此外，您应该使用按摘要拉取等功能从仓库中获取特定镜像。您可以按照以下步骤在系统上找到未使用的镜像，以便将其删除。\r\n步骤1：通过执行docker images --quiet | xargs docker inspect --format '{{ .Id }}: Image={{ .Config.Image }}'命令，列出当前实例化的所有镜像ID。\r\n步骤2：通过执行docker images命令列出系统上的所有镜像\r\n步骤3：比较从步骤1和步骤2创建的镜像ID列表，以找出当前尚未实例化的镜像。\r\n步骤4：确定是否要保留当前未使用的镜像。如果不需要它们，请执行docker rmi $IMAGE_ID命令删除它们。\r\n或者，docker system prune命令可用于删除未标记的悬挂镜像，如有必要，与-a选项一起使用时删除运行容器当前未使用的所有镜像。",
          "impact": "docker system prune -a 删除所有退出的容器以及运行容器未引用的所有镜像和卷，包括UCP和DTR。这在三种情况下可能会带来问题：\r\n1.在离线环境中，镜像删除将导致需要将镜像重新加载到主机。\r\n2.在DTR主机上，节点不会自动重新加入DTR集群和system prune -a可能会删除DTR卷并擦除所有DTR状态。\r\n3.在DTR或UCP主机上，docker system prune -a 同时在大多数UCP管理器或DTR节点上发布，同时停止相应的组件UCP或DTR。这可能会导致quorum和/或data的损失。",
          "default_value": "镜像和分层文件系统仍然可以在主机上访问，直到管理员删除引用这些镜像或镜像层的所有标签。",
          "references": "http://craiccomputing.blogspot.in/2014/09/clean-up-unused-docker-containers-and.html\r\nhttps://forums.docker.com/t/command-to-remove-all-unused-images/20/8\r\nhttps://github.com/docker/docker/issues/9054\r\nhttps://docs.docker.com/engine/reference/commandline/rmi/\r\nhttps://docs.docker.com/engine/reference/commandline/pull/\r\nhttps://github.com/docker/docker/pull/11109",
          "auto": false
        },
        {
          "id": "6.2",
          "title": "确保避免容器无序扩张",
          "profile_application": "Level 1 - Linux Host OS",
          "description": "您不应该在同一台主机上保留大量容器。",
          "rationale": "容器的灵活性使运行多个应用程序实例变得容易，因此间接导致Docker镜像可能存在于不同的安全补丁级别。这也意味着您正在消耗本可用于运行“有用”容器的主机资源。在特定主机上拥有超过必要数量的容器，使系统容易受到处理不当、配置错误和碎片化的影响。因此，您应该将给定主机上的容器数量保持在与服务生产应用程序相称的最低数量。",
          "audit": "步骤1：查找主机上的容器总数：docker info --format '{{ .Containers }}'\r\n步骤2：执行以下命令，以查找主机上实际运行或处于停止状态的容器总数。\ndocker info --format '{{ .ContainersStopped }}' docker info --format '{{ .ContainersRunning }}'\n如果在主机上停止的容器数量与实际运行的容器数量之间的差异过大，您可能会遭受“容器无序扩张”，并应检查未使用的容器以进行可能的删除。\r\n",
          "remediation": "您应该定期检查每个主机上的容器库存，并使用以下命令清理未使用中的容器：docker container prune",
          "impact": "您应该保留正在积极使用的容器，并删除不再需要的容器。",
          "default_value": "默认情况下，Docker不会限制您在主机上可能拥有的容器数量。",
          "references": "https://zeltser.com/security-risks-and-benefits-of-docker-application/\r\nhttp://searchsdn.techtarget.com/feature/Docker-networking-How-Linux-containers-will-change-your-network",
          "auto": false
        }
      ]
    },
    {
      "id": "7",
      "title": "Docker Swarm配置",
      "description": "本节列出了改变和保护Docker Swarm行为的建议。如果您不使用Docker Swarm，则本节中的建议不适用。",
      "checks": [
        {
          "id": "7.1",
          "title": "确保swarm模式未启用（如果需要）",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "除非需要，否则不要在Docker引擎实例上启用swarm模式。",
          "rationale": "默认情况下，Docker引擎实例不会在任何网络端口上监听，与客户端的所有通信都来自Unix套接字。当在Docker引擎实例上启用Docker swarm模式时，系统上将打开多个网络端口，并提供给网络上的其他系统，用于集群管理和节点通信。\r\n在系统上打开网络端口会增加其攻击面，除非需要，否则应避免这样做。应该注意的是，Docker Enterprise组件的运行需要swarm模式。",
          "audit": "您应该查看docker info命令的输出。如果输出包括Swarm：active，则表示Docker引擎上已激活swarm模式。在这种情况下，您应该确认Docker引擎实例上的swarm模式是否真的需要。",
          "remediation": "如果错误地在系统上启用了swarm模式，您应该运行以下命令：docker swarm leave",
          "impact": "如果正在使用，禁用swarm模式将影响Docker Enterprise组件的操作。",
          "default_value": "默认情况下，Docker swarm模式未启用。",
          "references": "https://docs.docker.com/engine/reference/commandline/swarm_init/",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "7.2",
          "title": "确保在swarm中创建了最小数量的管理器节点",
          "profile_application": "Level 1 - Docker - Linux\r\nLevel 1 - Docker Engine - Enterprise",
          "description": "您应该确保在swarm中创建所需的最小数量的管理器节点。",
          "rationale": "swarm中的管理器节点可以控制swarm，并可以更改其配置，包括修改安全参数。拥有过多的管理器节点可能会使swarm更容易受入侵。\r\n如果管理器节点不需要容错，则应选择单个节点作为管理器。如果需要容错，则应配置实现适当公差水平的最小奇数。这应该始终是一个奇数，以确保达到quorum。",
          "audit": "运行docker info --format '{{ .Swarm.Managers }}'并验证管理器个数。或者运行docker node ls | grep 'Leader'命令。",
          "remediation": "如果配置了过多的管理器，可以使用docker node demote <ID>命令将多余的节点降级为工作节点。",
          "impact": "无",
          "default_value": "启动给定swarm只需要一个控制器。",
          "references": "https://docs.docker.com/engine/swarm/manage-nodes/\r\nhttps://docs.docker.com/engine/swarm/admin_guide/#/add-manager-nodes-for-fault-tolerance",
          "auto": false,
          "level": "medium"
        },
        {
          "id": "7.3",
          "title": "确保swarm服务绑定到特定的主机接口",
          "profile_application": "Level 1 - Docker - Linux\r\nLevel 1 - Docker - Linux\r\nLevel 1 - Docker Engine - Enterprise",
          "description": "默认情况下，Docker的swarm服务将监听主机上的所有接口。对于主机具有多个网络接口的swarm的操作来说，这可能没有必要。",
          "rationale": "当swarm初始化时，--listen-addr标志的默认值为0.0.0.0:2377，这意味着swarm服务将监听主机上的所有接口。如果主机有多个网络接口，这可能是不可取的，因为它可能会将群服务暴露给与swarm操作不相关的网络。通过将特定的IP地址传递给--listen-addr，可以指定特定的网络接口，从而限制这种曝光。",
          "audit": "您应该检查端口2377/TCP（docker swarm的默认值）上的网络监听器，并确认它只在特定接口上监听。例如，在Ubuntu中，可以使用以下命令完成：netstat -lt | grep -i 2377",
          "remediation": "解决这个问题需要重新初始化swarm，为--listen-addr参数指定一个特定的接口。",
          "impact": "无",
          "default_value": "默认情况下，Docker swarm服务会监听所有可用的主机接口。",
          "references": "https://docs.docker.com/engine/reference/commandline/swarm_init/#--listen- addr\r\nhttps://docs.docker.com/engine/swarm/admin_guide/#recover-from-disaster",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "7.4",
          "title": "确保所有Docker swarm 延展网络都已加密",
          "profile_application": "Level 1 - Docker - Linux\r\nLevel 1 - Docker Engine - Enterprise\r\n",
          "description": "确保所有Docker swarm 延展网络都已加密",
          "rationale": "默认情况下，延展网络节点上的容器之间交换的数据不会加密。这可能会暴露容器之间的流量。",
          "audit": "您应该运行docker network ls --filter driver=overlay --quiet | xargs docker network inspect --format '{{.Name}} {{ .Options }}'命令，以确保每个覆盖网络都已加密。",
          "remediation": "您应该使用--opt encrypted 标志创建覆盖网络。",
          "impact": "无",
          "default_value": "默认情况下，在Docker群模式下在覆盖网络中交换的数据不会加密。",
          "references": "https://docs.docker.com/engine/userguide/networking/overlay-security-model/\r\nhttps://github.com/docker/docker/issues/24253",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "7.5",
          "title": "确保Docker的机密管理命令用于管理swarm集群中的机密",
          "profile_application": "Level 2 - Docker - Linux\r\nLevel 2 - Docker Engine - Enterprise",
          "description": "您应该使用Docker内置的机密管理命令来控制机密。",
          "rationale": "Docker有各种命令来管理swarm集群中的机密。",
          "audit": "在swarm管理器节点上，您应该运行docker secret ls命令，并确保 docker secret管理在您的环境中使用，这符合您的IT安全策略。",
          "remediation": "您应该遵循docker secret 文档，并使用它来有效地管理秘密。",
          "impact": "无",
          "default_value": "不适用",
          "references": "https://docs.docker.com/engine/reference/commandline/secret/",
          "auto": false
        },
        {
          "id": "7.6",
          "title": "确保swarm管理器在auto-lock模式下运行",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您应该查看您是否希望在auto-lock模式下运行Docker swarm管理器。",
          "rationale": "当Docker重新启动时，用于加密swarm节点之间通信的TLS密钥以及用于加密和解密磁盘上的Rft日志的密钥都会加载到每个管理器节点的内存中。您可以保护相互TLS加密密钥以及用于加密和解密Raft日志的密钥。可以通过使用--autolock标志初始化swarm来启用此保护。\r\n启用--autolock后，当Docker重新启动时，您必须首先使用Docker在群初始化时生成的密钥解锁swarm。",
          "audit": "您应该运行docker info --format 'Swarm Autolock: {{ .Swarm.Cluster.Spec.EncryptionConfig.AutoLockManagers }}'命令,如果结果为真，则启用自动锁定模式。您也可以运行docker swarm unlock-key命令。如果返回键值，则表示swarm已使用--autolock标志初始化。如果输出no unlock key is set，则表示swarm没有使用--autolock标志初始化。这应该根据组织的IT安全政策进行审查。",
          "remediation": "如果您正在初始化swarm，请使用docker swarm init --autolock命令。\r\n如果您想在现有的群管理器节点上设置--autolock，请使用\ndocker swarm update --autolock命令。",
          "impact": "如果没有管理员手动干预输入解锁密钥，自动锁定模式下的swarm将无法从重新启动中恢复。这可能并不总是可取的，应该在政策层面进行审查。",
          "default_value": "默认情况下，swarm管理器不会在自动锁定模式下运行。",
          "references": "https://docs.docker.com/engine/swarm/swarm_manager_locking/",
          "auto": true,
          "level": "medium"
        },
        {
          "id": "7.7",
          "title": "确保swarm管理器自动锁定键定期轮询",
          "profile_application": "Level 1 - Docker - Linux",
          "description": "您应该定期轮询swarm管理器自动锁定密钥。",
          "rationale": "群管理器自动锁定键不会自动轮询。良好的安全实践是轮询秘钥。",
          "audit": "目前，没有机制来找出密钥最后一次在swarm管理器节点上轮询的时间。您应该咨询系统管理员，看看是否有密钥轮询过程，以及密钥轮询的频率。",
          "remediation": "您应该运行docker swarm unlock-key --rotate命令来轮询秘钥。此外，为了便于对本建议的审计，您应该维护密钥轮询记录，并确保您为密钥轮询建立预定义的频率。",
          "impact": "无",
          "default_value": "默认情况下，按键不会自动轮询。",
          "references": "https://docs.docker.com/engine/reference/commandline/swarm_unlock-key/",
          "auto": false
        },
        {
          "id": "7.8",
          "title": "确保节点证书已酌情轮询",
          "profile_application": "Level 2 - Docker - Linux\r\nLevel 2 - Docker Engine - Enterprise",
          "description": "您应该根据您的组织安全策略轮询群节点证书。",
          "rationale": "Docker Swarm使用TLS在其节点之间进行集群操作。证书轮询确保在节点或密钥受损等情况下，很难冒充节点。默认情况下，节点证书每90天轮询一次，但您应该在环境中更频繁地或酌情轮询它们。",
          "audit": "运行docker info | grep \"Expiry Duration\"\ndocker info --format 'NodeCertExpiry: {{ .Swarm.Cluster.Spec.CAConfig.NodeCertExpiry }}'命令，并确保节点证书过期持续时间设置得适当。",
          "remediation": "您应该运行docker swarm update --cert-expiry 48h命令，在节点证书上设置所需的到期时间。",
          "impact": "无",
          "default_value": "默认情况下，节点证书每90天自动轮询一次。",
          "references": "https://docs.docker.com/engine/reference/commandline/swarm_update/#examples",
          "auto": false
        },
        {
          "id": "7.9",
          "title": "确保CA证书酌情轮询",
          "profile_application": "Level 2 - Docker - Linux",
          "description": "您应该酌情轮询 root CA证书。",
          "rationale": "Docker Swarm使用TLS在其节点之间进行集群操作。证书轮询确保在节点或密钥受损等情况下，很难冒充节点。节点证书取决于根CA证书。为了运营安全，经常轮询这些很重要。目前，根CA证书不会自动轮询，因此您应该根据您的组织安全策略建立轮询它们的过程。",
          "audit": "您应该检查 root CA证书文件上的时间戳。例如：ls -l /var/lib/docker/swarm/certificates/swarm-root-ca.crt\r\n证书应显示符合组织轮询政策的时间戳。",
          "remediation": "您应该运行docker swarm ca --rotate命令来轮询证书。",
          "impact": "无",
          "default_value": "默认情况下，root CA证书不会轮询。",
          "references": "https://docs.docker.com/engine/swarm/how-swarm-mode-works/pki/#rotating-the-ca-certificate",
          "auto": false
        },
        {
          "id": "7.10",
          "title": "确保管理平面流量与数据平面流量分开",
          "profile_application": "Level 2 - Docker - Linux\r\nLevel 2 - Docker Engine - Enterprise",
          "description": "您应该将管理平面流量与数据平面流量分开。",
          "rationale": "将管理平面流量与数据平面流量分开，确保这些类型的流量相互隔离。然后，这些交通流可以单独监控，并与不同的交通控制政策和监控绑定。这也确保了即使数据平面上有很多流量，管理平面也始终可以到达。",
          "audit": "您应该在每个群节点上运行docker node inspect --format '{{ .Status.Addr }}' self命令，并确保管理平面地址与数据平面地址不同。",
          "remediation": "您应该分别使用管理和数据平面的专用接口初始化swarm:docker swarm init --advertise-addr=192.168.0.1 --data-path-addr=17.1.0.3\n",
          "impact": "这需要每个节点有两个网络接口。",
          "default_value": "默认情况下，数据平面流量不会与管理平面流量分开。",
          "references": "https://docs.docker.com/engine/reference/commandline/swarm_init/#--data-path-addr\r\nhttps://github.com/moby/moby/issues/33938\r\nhttps://github.com/moby/moby/pull/32717",
          "auto": false
        }
      ]
    }
  ]
}